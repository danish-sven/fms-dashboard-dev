{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { Framebuffer, Renderbuffer, Texture2D, cssToDeviceRatio } from '@luma.gl/core';\nimport { equals } from '@math.gl/core';\nimport { _deepEqual as deepEqual } from '@deck.gl/core';\nimport CollisionFilterPass from './collision-filter-pass';\nimport MaskEffect from '../mask/mask-effect';\nconst DOWNSCALE = 2;\nexport default class CollisionFilterEffect {\n  constructor() {\n    _defineProperty(this, \"id\", 'collision-filter-effect');\n    _defineProperty(this, \"props\", null);\n    _defineProperty(this, \"useInPicking\", true);\n    _defineProperty(this, \"order\", 1);\n    _defineProperty(this, \"channels\", {});\n    _defineProperty(this, \"collisionFilterPass\", void 0);\n    _defineProperty(this, \"collisionFBOs\", {});\n    _defineProperty(this, \"dummyCollisionMap\", void 0);\n    _defineProperty(this, \"lastViewport\", void 0);\n  }\n  preRender(gl, _ref) {\n    let {\n      effects: allEffects,\n      layers,\n      layerFilter,\n      viewports,\n      onViewportActive,\n      views,\n      isPicking,\n      preRenderStats = {}\n    } = _ref;\n    var _preRenderStats$mask;\n    if (!this.dummyCollisionMap) {\n      this.dummyCollisionMap = new Texture2D(gl, {\n        width: 1,\n        height: 1\n      });\n    }\n    if (isPicking) {\n      return;\n    }\n    const collisionLayers = layers.filter(_ref2 => {\n      let {\n        props: {\n          visible,\n          collisionEnabled\n        }\n      } = _ref2;\n      return visible && collisionEnabled;\n    });\n    if (collisionLayers.length === 0) {\n      this.channels = {};\n      return;\n    }\n    if (!this.collisionFilterPass) {\n      this.collisionFilterPass = new CollisionFilterPass(gl, {\n        id: 'default-collision-filter'\n      });\n    }\n    const effects = allEffects === null || allEffects === void 0 ? void 0 : allEffects.filter(e => e.constructor === MaskEffect);\n    const maskEffectRendered = (_preRenderStats$mask = preRenderStats['mask-effect']) === null || _preRenderStats$mask === void 0 ? void 0 : _preRenderStats$mask.didRender;\n    const channels = this._groupByCollisionGroup(gl, collisionLayers);\n    const viewport = viewports[0];\n    const viewportChanged = !this.lastViewport || !this.lastViewport.equals(viewport) || maskEffectRendered;\n    for (const collisionGroup in channels) {\n      const collisionFBO = this.collisionFBOs[collisionGroup];\n      const renderInfo = channels[collisionGroup];\n      collisionFBO.resize({\n        width: gl.canvas.width / DOWNSCALE,\n        height: gl.canvas.height / DOWNSCALE\n      });\n      this._render(renderInfo, {\n        effects,\n        layerFilter,\n        onViewportActive,\n        views,\n        viewport,\n        viewportChanged\n      });\n    }\n  }\n  _render(renderInfo, _ref3) {\n    let {\n      effects,\n      layerFilter,\n      onViewportActive,\n      views,\n      viewport,\n      viewportChanged\n    } = _ref3;\n    const {\n      collisionGroup\n    } = renderInfo;\n    const oldRenderInfo = this.channels[collisionGroup];\n    if (!oldRenderInfo) {\n      return;\n    }\n    const needsRender = viewportChanged || renderInfo === oldRenderInfo || !deepEqual(oldRenderInfo.layers, renderInfo.layers, 1) || renderInfo.layerBounds.some((b, i) => !equals(b, oldRenderInfo.layerBounds[i])) || renderInfo.allLayersLoaded !== oldRenderInfo.allLayersLoaded || renderInfo.layers.some(layer => layer.props.transitions);\n    this.channels[collisionGroup] = renderInfo;\n    if (needsRender) {\n      this.lastViewport = viewport;\n      const collisionFBO = this.collisionFBOs[collisionGroup];\n      this.collisionFilterPass.renderCollisionMap(collisionFBO, {\n        pass: 'collision-filter',\n        isPicking: true,\n        layers: renderInfo.layers,\n        effects,\n        layerFilter,\n        viewports: viewport ? [viewport] : [],\n        onViewportActive,\n        views,\n        moduleParameters: {\n          dummyCollisionMap: this.dummyCollisionMap,\n          devicePixelRatio: cssToDeviceRatio(collisionFBO.gl) / DOWNSCALE\n        }\n      });\n    }\n  }\n  _groupByCollisionGroup(gl, collisionLayers) {\n    const channelMap = {};\n    for (const layer of collisionLayers) {\n      const {\n        collisionGroup\n      } = layer.props;\n      let channelInfo = channelMap[collisionGroup];\n      if (!channelInfo) {\n        channelInfo = {\n          collisionGroup,\n          layers: [],\n          layerBounds: [],\n          allLayersLoaded: true\n        };\n        channelMap[collisionGroup] = channelInfo;\n      }\n      channelInfo.layers.push(layer);\n      channelInfo.layerBounds.push(layer.getBounds());\n      if (!layer.isLoaded) {\n        channelInfo.allLayersLoaded = false;\n      }\n    }\n    for (const collisionGroup of Object.keys(channelMap)) {\n      if (!this.collisionFBOs[collisionGroup]) {\n        this.createFBO(gl, collisionGroup);\n      }\n      if (!this.channels[collisionGroup]) {\n        this.channels[collisionGroup] = channelMap[collisionGroup];\n      }\n    }\n    for (const collisionGroup of Object.keys(this.collisionFBOs)) {\n      if (!channelMap[collisionGroup]) {\n        this.destroyFBO(collisionGroup);\n      }\n    }\n    return channelMap;\n  }\n  getModuleParameters(layer) {\n    const {\n      collisionGroup\n    } = layer.props;\n    const {\n      collisionFBOs,\n      dummyCollisionMap\n    } = this;\n    return {\n      collisionFBO: collisionFBOs[collisionGroup],\n      dummyCollisionMap\n    };\n  }\n  cleanup() {\n    if (this.dummyCollisionMap) {\n      this.dummyCollisionMap.delete();\n      this.dummyCollisionMap = undefined;\n    }\n    this.channels = {};\n    for (const collisionGroup of Object.keys(this.collisionFBOs)) {\n      this.destroyFBO(collisionGroup);\n    }\n    this.collisionFBOs = {};\n    this.lastViewport = undefined;\n  }\n  createFBO(gl, collisionGroup) {\n    const {\n      width,\n      height\n    } = gl.canvas;\n    const collisionMap = new Texture2D(gl, {\n      width,\n      height,\n      parameters: {\n        [10241]: 9728,\n        [10240]: 9728,\n        [10242]: 33071,\n        [10243]: 33071\n      }\n    });\n    const depthBuffer = new Renderbuffer(gl, {\n      format: 33189,\n      width,\n      height\n    });\n    this.collisionFBOs[collisionGroup] = new Framebuffer(gl, {\n      id: \"Collision-\".concat(collisionGroup),\n      width,\n      height,\n      attachments: {\n        [36064]: collisionMap,\n        [36096]: depthBuffer\n      }\n    });\n  }\n  destroyFBO(collisionGroup) {\n    const fbo = this.collisionFBOs[collisionGroup];\n    for (const attachment of Object.values(fbo.attachments)) {\n      attachment.delete();\n    }\n    fbo.delete();\n    delete this.collisionFBOs[collisionGroup];\n  }\n}","map":{"version":3,"names":["Framebuffer","Renderbuffer","Texture2D","cssToDeviceRatio","equals","_deepEqual","deepEqual","CollisionFilterPass","MaskEffect","DOWNSCALE","CollisionFilterEffect","constructor","_defineProperty","preRender","gl","_ref","effects","allEffects","layers","layerFilter","viewports","onViewportActive","views","isPicking","preRenderStats","_preRenderStats$mask","dummyCollisionMap","width","height","collisionLayers","filter","_ref2","props","visible","collisionEnabled","length","channels","collisionFilterPass","id","e","maskEffectRendered","didRender","_groupByCollisionGroup","viewport","viewportChanged","lastViewport","collisionGroup","collisionFBO","collisionFBOs","renderInfo","resize","canvas","_render","_ref3","oldRenderInfo","needsRender","layerBounds","some","b","i","allLayersLoaded","layer","transitions","renderCollisionMap","pass","moduleParameters","devicePixelRatio","channelMap","channelInfo","push","getBounds","isLoaded","Object","keys","createFBO","destroyFBO","getModuleParameters","cleanup","delete","undefined","collisionMap","parameters","depthBuffer","format","concat","attachments","fbo","attachment","values"],"sources":["../../../src/collision-filter/collision-filter-effect.ts"],"sourcesContent":["import {Framebuffer, Renderbuffer, Texture2D, cssToDeviceRatio} from '@luma.gl/core';\nimport {equals} from '@math.gl/core';\nimport {_deepEqual as deepEqual} from '@deck.gl/core';\nimport type {Effect, Layer, PreRenderOptions, Viewport} from '@deck.gl/core';\nimport CollisionFilterPass from './collision-filter-pass';\nimport MaskEffect, {MaskPreRenderStats} from '../mask/mask-effect';\n// import {debugFBO} from '../utils/debug';\n\ntype CollisionFilterExtensionProps = {\n  collisionTestProps?: {};\n  collisionGroup: string;\n};\n\n// Factor by which to downscale Collision FBO relative to canvas\nconst DOWNSCALE = 2;\n\ntype RenderInfo = {\n  collisionGroup: string;\n  layers: Layer<CollisionFilterExtensionProps>[];\n  layerBounds: ([number[], number[]] | null)[];\n  allLayersLoaded: boolean;\n};\n\nexport default class CollisionFilterEffect implements Effect {\n  id = 'collision-filter-effect';\n  props = null;\n  useInPicking = true;\n  order = 1;\n\n  private channels: Record<string, RenderInfo> = {};\n  private collisionFilterPass?: CollisionFilterPass;\n  private collisionFBOs: Record<string, Framebuffer> = {};\n  private dummyCollisionMap?: Texture2D;\n  private lastViewport?: Viewport;\n\n  preRender(\n    gl: WebGLRenderingContext,\n    {\n      effects: allEffects,\n      layers,\n      layerFilter,\n      viewports,\n      onViewportActive,\n      views,\n      isPicking,\n      preRenderStats = {}\n    }: PreRenderOptions\n  ): void {\n    if (!this.dummyCollisionMap) {\n      this.dummyCollisionMap = new Texture2D(gl, {width: 1, height: 1});\n    }\n\n    if (isPicking) {\n      // Do not update on picking pass\n      return;\n    }\n\n    const collisionLayers = layers.filter(\n      // @ts-ignore\n      ({props: {visible, collisionEnabled}}) => visible && collisionEnabled\n    ) as Layer<CollisionFilterExtensionProps>[];\n    if (collisionLayers.length === 0) {\n      this.channels = {};\n      return;\n    }\n\n    if (!this.collisionFilterPass) {\n      this.collisionFilterPass = new CollisionFilterPass(gl, {id: 'default-collision-filter'});\n    }\n\n    // Detect if mask has rendered. TODO: better dependency system for Effects\n    const effects = allEffects?.filter(e => e.constructor === MaskEffect);\n    const maskEffectRendered = (preRenderStats['mask-effect'] as MaskPreRenderStats)?.didRender;\n\n    // Collect layers to render\n    const channels = this._groupByCollisionGroup(gl, collisionLayers);\n\n    const viewport = viewports[0];\n    const viewportChanged =\n      !this.lastViewport || !this.lastViewport.equals(viewport) || maskEffectRendered;\n\n    // Resize framebuffers to match canvas\n    for (const collisionGroup in channels) {\n      const collisionFBO = this.collisionFBOs[collisionGroup];\n      const renderInfo = channels[collisionGroup];\n      collisionFBO.resize({\n        width: gl.canvas.width / DOWNSCALE,\n        height: gl.canvas.height / DOWNSCALE\n      });\n      this._render(renderInfo, {\n        effects,\n        layerFilter,\n        onViewportActive,\n        views,\n        viewport,\n        viewportChanged\n      });\n    }\n\n    // debugFBO(this.collisionFBOs[Object.keys(channels)[0]], {minimap: true});\n  }\n\n  private _render(\n    renderInfo: RenderInfo,\n    {\n      effects,\n      layerFilter,\n      onViewportActive,\n      views,\n      viewport,\n      viewportChanged\n    }: {\n      effects: PreRenderOptions['effects'];\n      layerFilter: PreRenderOptions['layerFilter'];\n      onViewportActive: PreRenderOptions['onViewportActive'];\n      views: PreRenderOptions['views'];\n      viewport: Viewport;\n      viewportChanged: boolean;\n    }\n  ) {\n    const {collisionGroup} = renderInfo;\n    const oldRenderInfo = this.channels[collisionGroup];\n    if (!oldRenderInfo) {\n      return;\n    }\n\n    const needsRender =\n      viewportChanged ||\n      // If render info is new\n      renderInfo === oldRenderInfo ||\n      // If sublayers have changed\n      !deepEqual(oldRenderInfo.layers, renderInfo.layers, 1) ||\n      // If a sublayer's bounds have been updated\n      renderInfo.layerBounds.some((b, i) => !equals(b, oldRenderInfo.layerBounds[i])) ||\n      // If a sublayer's isLoaded state has been updated\n      renderInfo.allLayersLoaded !== oldRenderInfo.allLayersLoaded ||\n      // Some prop is in transition\n      renderInfo.layers.some(layer => layer.props.transitions);\n\n    this.channels[collisionGroup] = renderInfo;\n\n    if (needsRender) {\n      this.lastViewport = viewport;\n      const collisionFBO = this.collisionFBOs[collisionGroup];\n\n      // Rerender collision FBO\n      this.collisionFilterPass!.renderCollisionMap(collisionFBO, {\n        pass: 'collision-filter',\n        isPicking: true,\n        layers: renderInfo.layers,\n        effects,\n        layerFilter,\n        viewports: viewport ? [viewport] : [],\n        onViewportActive,\n        views,\n        moduleParameters: {\n          // To avoid feedback loop forming between Framebuffer and active Texture.\n          dummyCollisionMap: this.dummyCollisionMap,\n          devicePixelRatio: cssToDeviceRatio(collisionFBO.gl) / DOWNSCALE\n        }\n      });\n    }\n  }\n\n  /**\n   * Group layers by collisionGroup\n   * Returns a map from collisionGroup to render info\n   */\n  private _groupByCollisionGroup(\n    gl: WebGLRenderingContext,\n    collisionLayers: Layer<CollisionFilterExtensionProps>[]\n  ): Record<string, RenderInfo> {\n    const channelMap = {};\n    for (const layer of collisionLayers) {\n      const {collisionGroup} = layer.props;\n      let channelInfo = channelMap[collisionGroup];\n      if (!channelInfo) {\n        channelInfo = {collisionGroup, layers: [], layerBounds: [], allLayersLoaded: true};\n        channelMap[collisionGroup] = channelInfo;\n      }\n      channelInfo.layers.push(layer);\n      channelInfo.layerBounds.push(layer.getBounds());\n      if (!layer.isLoaded) {\n        channelInfo.allLayersLoaded = false;\n      }\n    }\n\n    // Create any new passes and remove any old ones\n    for (const collisionGroup of Object.keys(channelMap)) {\n      if (!this.collisionFBOs[collisionGroup]) {\n        this.createFBO(gl, collisionGroup);\n      }\n      if (!this.channels[collisionGroup]) {\n        this.channels[collisionGroup] = channelMap[collisionGroup];\n      }\n    }\n    for (const collisionGroup of Object.keys(this.collisionFBOs)) {\n      if (!channelMap[collisionGroup]) {\n        this.destroyFBO(collisionGroup);\n      }\n    }\n\n    return channelMap;\n  }\n\n  getModuleParameters(layer: Layer): {\n    collisionFBO: Framebuffer;\n    dummyCollisionMap: Texture2D;\n  } {\n    const {collisionGroup} = (layer as Layer<CollisionFilterExtensionProps>).props;\n    const {collisionFBOs, dummyCollisionMap} = this;\n    return {collisionFBO: collisionFBOs[collisionGroup], dummyCollisionMap};\n  }\n\n  cleanup(): void {\n    if (this.dummyCollisionMap) {\n      this.dummyCollisionMap.delete();\n      this.dummyCollisionMap = undefined;\n    }\n    this.channels = {};\n    for (const collisionGroup of Object.keys(this.collisionFBOs)) {\n      this.destroyFBO(collisionGroup);\n    }\n    this.collisionFBOs = {};\n    this.lastViewport = undefined;\n  }\n\n  createFBO(gl: WebGLRenderingContext, collisionGroup: string) {\n    const {width, height} = gl.canvas;\n    const collisionMap = new Texture2D(gl, {\n      width,\n      height,\n      parameters: {\n        [gl.TEXTURE_MIN_FILTER]: gl.NEAREST,\n        [gl.TEXTURE_MAG_FILTER]: gl.NEAREST,\n        [gl.TEXTURE_WRAP_S]: gl.CLAMP_TO_EDGE,\n        [gl.TEXTURE_WRAP_T]: gl.CLAMP_TO_EDGE\n      }\n    });\n\n    const depthBuffer = new Renderbuffer(gl, {format: gl.DEPTH_COMPONENT16, width, height});\n    this.collisionFBOs[collisionGroup] = new Framebuffer(gl, {\n      id: `Collision-${collisionGroup}`,\n      width,\n      height,\n      attachments: {\n        [gl.COLOR_ATTACHMENT0]: collisionMap,\n        [gl.DEPTH_ATTACHMENT]: depthBuffer\n      }\n    });\n  }\n\n  destroyFBO(collisionGroup: string) {\n    const fbo = this.collisionFBOs[collisionGroup];\n    for (const attachment of Object.values(fbo.attachments as Texture2D[])) {\n      attachment.delete();\n    }\n    fbo.delete();\n    delete this.collisionFBOs[collisionGroup];\n  }\n}\n"],"mappings":";AAAA,SAAQA,WAAR,EAAqBC,YAArB,EAAmCC,SAAnC,EAA8CC,gBAA9C,QAAqE,eAArE;AACA,SAAQC,MAAR,QAAqB,eAArB;AACA,SAAQC,UAAU,IAAIC,SAAtB,QAAsC,eAAtC;AAEA,OAAOC,mBAAP,MAAgC,yBAAhC;AACA,OAAOC,UAAP,MAA6C,qBAA7C;AASA,MAAMC,SAAS,GAAG,CAAlB;AASA,eAAe,MAAMC,qBAAN,CAA8C;EAAAC,YAAA;IAAAC,eAAA,aACtD,yBADsD;IAAAA,eAAA,gBAEnD,IAFmD;IAAAA,eAAA,uBAG5C,IAH4C;IAAAA,eAAA,gBAInD,CAJmD;IAAAA,eAAA,mBAMZ,EANY;IAAAA,eAAA;IAAAA,eAAA,wBAQN,EARM;IAAAA,eAAA;IAAAA,eAAA;EAAA;EAY3DC,SAASA,CACPC,EADO,EAAAC,IAAA,EAYD;IAAA,IAVN;MACEC,OAAO,EAAEC,UADX;MAEEC,MAFF;MAGEC,WAHF;MAIEC,SAJF;MAKEC,gBALF;MAMEC,KANF;MAOEC,SAPF;MAQEC,cAAc,GAAG;IARnB,CAFO,GAAAT,IAAA;IAYD,IAAAU,oBAAA;IACN,IAAI,CAAC,KAAKC,iBAAV,EAA6B;MAC3B,KAAKA,iBAAL,GAAyB,IAAIxB,SAAJ,CAAcY,EAAd,EAAkB;QAACa,KAAK,EAAE,CAAR;QAAWC,MAAM,EAAE;MAAnB,CAAlB,CAAzB;IACD;IAED,IAAIL,SAAJ,EAAe;MAEb;IACD;IAED,MAAMM,eAAe,GAAGX,MAAM,CAACY,MAAP,CAEtBC,KAAA;MAAA,IAAC;QAACC,KAAK,EAAE;UAACC,OAAD;UAAUC;QAAV;MAAR,CAAD,GAAAH,KAAA;MAAA,OAA0CE,OAAO,IAAIC,gBAF/B;IAAA,EAAxB;IAIA,IAAIL,eAAe,CAACM,MAAhB,KAA2B,CAA/B,EAAkC;MAChC,KAAKC,QAAL,GAAgB,EAAhB;MACA;IACD;IAED,IAAI,CAAC,KAAKC,mBAAV,EAA+B;MAC7B,KAAKA,mBAAL,GAA2B,IAAI9B,mBAAJ,CAAwBO,EAAxB,EAA4B;QAACwB,EAAE,EAAE;MAAL,CAA5B,CAA3B;IACD;IAGD,MAAMtB,OAAO,GAAGC,UAAH,aAAGA,UAAH,uBAAGA,UAAU,CAAEa,MAAZ,CAAmBS,CAAC,IAAIA,CAAC,CAAC5B,WAAF,KAAkBH,UAA1C,CAAhB;IACA,MAAMgC,kBAAkB,IAAAf,oBAAA,GAAID,cAAc,CAAC,aAAD,CAAlB,cAAAC,oBAAA,uBAAGA,oBAAA,CAAuDgB,SAAlF;IAGA,MAAML,QAAQ,GAAG,KAAKM,sBAAL,CAA4B5B,EAA5B,EAAgCe,eAAhC,CAAjB;IAEA,MAAMc,QAAQ,GAAGvB,SAAS,CAAC,CAAD,CAA1B;IACA,MAAMwB,eAAe,GACnB,CAAC,KAAKC,YAAN,IAAsB,CAAC,KAAKA,YAAL,CAAkBzC,MAAlB,CAAyBuC,QAAzB,CAAvB,IAA6DH,kBAD/D;IAIA,KAAK,MAAMM,cAAX,IAA6BV,QAA7B,EAAuC;MACrC,MAAMW,YAAY,GAAG,KAAKC,aAAL,CAAmBF,cAAnB,CAArB;MACA,MAAMG,UAAU,GAAGb,QAAQ,CAACU,cAAD,CAA3B;MACAC,YAAY,CAACG,MAAb,CAAoB;QAClBvB,KAAK,EAAEb,EAAE,CAACqC,MAAH,CAAUxB,KAAV,GAAkBlB,SADP;QAElBmB,MAAM,EAAEd,EAAE,CAACqC,MAAH,CAAUvB,MAAV,GAAmBnB;MAFT,CAApB;MAIA,KAAK2C,OAAL,CAAaH,UAAb,EAAyB;QACvBjC,OADuB;QAEvBG,WAFuB;QAGvBE,gBAHuB;QAIvBC,KAJuB;QAKvBqB,QALuB;QAMvBC;MANuB,CAAzB;IAQD;EAGF;EAEOQ,OAAOA,CACbH,UADa,EAAAI,KAAA,EAiBb;IAAA,IAfA;MACErC,OADF;MAEEG,WAFF;MAGEE,gBAHF;MAIEC,KAJF;MAKEqB,QALF;MAMEC;IANF,CAFa,GAAAS,KAAA;IAkBb,MAAM;MAACP;IAAD,IAAmBG,UAAzB;IACA,MAAMK,aAAa,GAAG,KAAKlB,QAAL,CAAcU,cAAd,CAAtB;IACA,IAAI,CAACQ,aAAL,EAAoB;MAClB;IACD;IAED,MAAMC,WAAW,GACfX,eAAe,IAEfK,UAAU,KAAKK,aAFf,IAIA,CAAChD,SAAS,CAACgD,aAAa,CAACpC,MAAf,EAAuB+B,UAAU,CAAC/B,MAAlC,EAA0C,CAA1C,CAJV,IAMA+B,UAAU,CAACO,WAAX,CAAuBC,IAAvB,CAA4B,CAACC,CAAD,EAAIC,CAAJ,KAAU,CAACvD,MAAM,CAACsD,CAAD,EAAIJ,aAAa,CAACE,WAAd,CAA0BG,CAA1B,CAAJ,CAA7C,CANA,IAQAV,UAAU,CAACW,eAAX,KAA+BN,aAAa,CAACM,eAR7C,IAUAX,UAAU,CAAC/B,MAAX,CAAkBuC,IAAlB,CAAuBI,KAAK,IAAIA,KAAK,CAAC7B,KAAN,CAAY8B,WAA5C,CAXF;IAaA,KAAK1B,QAAL,CAAcU,cAAd,IAAgCG,UAAhC;IAEA,IAAIM,WAAJ,EAAiB;MACf,KAAKV,YAAL,GAAoBF,QAApB;MACA,MAAMI,YAAY,GAAG,KAAKC,aAAL,CAAmBF,cAAnB,CAArB;MAGA,KAAKT,mBAAL,CAA0B0B,kBAA1B,CAA6ChB,YAA7C,EAA2D;QACzDiB,IAAI,EAAE,kBADmD;QAEzDzC,SAAS,EAAE,IAF8C;QAGzDL,MAAM,EAAE+B,UAAU,CAAC/B,MAHsC;QAIzDF,OAJyD;QAKzDG,WALyD;QAMzDC,SAAS,EAAEuB,QAAQ,GAAG,CAACA,QAAD,CAAH,GAAgB,EANsB;QAOzDtB,gBAPyD;QAQzDC,KARyD;QASzD2C,gBAAgB,EAAE;UAEhBvC,iBAAiB,EAAE,KAAKA,iBAFR;UAGhBwC,gBAAgB,EAAE/D,gBAAgB,CAAC4C,YAAY,CAACjC,EAAd,CAAhB,GAAoCL;QAHtC;MATuC,CAA3D;IAeD;EACF;EAMOiC,sBAAsBA,CAC5B5B,EAD4B,EAE5Be,eAF4B,EAGA;IAC5B,MAAMsC,UAAU,GAAG,EAAnB;IACA,KAAK,MAAMN,KAAX,IAAoBhC,eAApB,EAAqC;MACnC,MAAM;QAACiB;MAAD,IAAmBe,KAAK,CAAC7B,KAA/B;MACA,IAAIoC,WAAW,GAAGD,UAAU,CAACrB,cAAD,CAA5B;MACA,IAAI,CAACsB,WAAL,EAAkB;QAChBA,WAAW,GAAG;UAACtB,cAAD;UAAiB5B,MAAM,EAAE,EAAzB;UAA6BsC,WAAW,EAAE,EAA1C;UAA8CI,eAAe,EAAE;QAA/D,CAAd;QACAO,UAAU,CAACrB,cAAD,CAAV,GAA6BsB,WAA7B;MACD;MACDA,WAAW,CAAClD,MAAZ,CAAmBmD,IAAnB,CAAwBR,KAAxB;MACAO,WAAW,CAACZ,WAAZ,CAAwBa,IAAxB,CAA6BR,KAAK,CAACS,SAAN,EAA7B;MACA,IAAI,CAACT,KAAK,CAACU,QAAX,EAAqB;QACnBH,WAAW,CAACR,eAAZ,GAA8B,KAA9B;MACD;IACF;IAGD,KAAK,MAAMd,cAAX,IAA6B0B,MAAM,CAACC,IAAP,CAAYN,UAAZ,CAA7B,EAAsD;MACpD,IAAI,CAAC,KAAKnB,aAAL,CAAmBF,cAAnB,CAAL,EAAyC;QACvC,KAAK4B,SAAL,CAAe5D,EAAf,EAAmBgC,cAAnB;MACD;MACD,IAAI,CAAC,KAAKV,QAAL,CAAcU,cAAd,CAAL,EAAoC;QAClC,KAAKV,QAAL,CAAcU,cAAd,IAAgCqB,UAAU,CAACrB,cAAD,CAA1C;MACD;IACF;IACD,KAAK,MAAMA,cAAX,IAA6B0B,MAAM,CAACC,IAAP,CAAY,KAAKzB,aAAjB,CAA7B,EAA8D;MAC5D,IAAI,CAACmB,UAAU,CAACrB,cAAD,CAAf,EAAiC;QAC/B,KAAK6B,UAAL,CAAgB7B,cAAhB;MACD;IACF;IAED,OAAOqB,UAAP;EACD;EAEDS,mBAAmBA,CAACf,KAAD,EAGjB;IACA,MAAM;MAACf;IAAD,IAAoBe,KAAD,CAAgD7B,KAAzE;IACA,MAAM;MAACgB,aAAD;MAAgBtB;IAAhB,IAAqC,IAA3C;IACA,OAAO;MAACqB,YAAY,EAAEC,aAAa,CAACF,cAAD,CAA5B;MAA8CpB;IAA9C,CAAP;EACD;EAEDmD,OAAOA,CAAA,EAAS;IACd,IAAI,KAAKnD,iBAAT,EAA4B;MAC1B,KAAKA,iBAAL,CAAuBoD,MAAvB;MACA,KAAKpD,iBAAL,GAAyBqD,SAAzB;IACD;IACD,KAAK3C,QAAL,GAAgB,EAAhB;IACA,KAAK,MAAMU,cAAX,IAA6B0B,MAAM,CAACC,IAAP,CAAY,KAAKzB,aAAjB,CAA7B,EAA8D;MAC5D,KAAK2B,UAAL,CAAgB7B,cAAhB;IACD;IACD,KAAKE,aAAL,GAAqB,EAArB;IACA,KAAKH,YAAL,GAAoBkC,SAApB;EACD;EAEDL,SAASA,CAAC5D,EAAD,EAA4BgC,cAA5B,EAAoD;IAC3D,MAAM;MAACnB,KAAD;MAAQC;IAAR,IAAkBd,EAAE,CAACqC,MAA3B;IACA,MAAM6B,YAAY,GAAG,IAAI9E,SAAJ,CAAcY,EAAd,EAAkB;MACrCa,KADqC;MAErCC,MAFqC;MAGrCqD,UAAU,EAAE;QACV,aADU;QAEV,aAFU;QAGV,cAHU;QAIV;MAJU;IAHyB,CAAlB,CAArB;IAWA,MAAMC,WAAW,GAAG,IAAIjF,YAAJ,CAAiBa,EAAjB,EAAqB;MAACqE,MAAM,OAAP;MAA+BxD,KAA/B;MAAsCC;IAAtC,CAArB,CAApB;IACA,KAAKoB,aAAL,CAAmBF,cAAnB,IAAqC,IAAI9C,WAAJ,CAAgBc,EAAhB,EAAoB;MACvDwB,EAAE,eAAA8C,MAAA,CAAetC,cAAf,CADqD;MAEvDnB,KAFuD;MAGvDC,MAHuD;MAIvDyD,WAAW,EAAE;QACX,SAAwBL,YADb;QAEX,SAAuBE;MAFZ;IAJ0C,CAApB,CAArC;EASD;EAEDP,UAAUA,CAAC7B,cAAD,EAAyB;IACjC,MAAMwC,GAAG,GAAG,KAAKtC,aAAL,CAAmBF,cAAnB,CAAZ;IACA,KAAK,MAAMyC,UAAX,IAAyBf,MAAM,CAACgB,MAAP,CAAcF,GAAG,CAACD,WAAlB,CAAzB,EAAwE;MACtEE,UAAU,CAACT,MAAX;IACD;IACDQ,GAAG,CAACR,MAAJ;IACA,OAAO,KAAK9B,aAAL,CAAmBF,cAAnB,CAAP;EACD;AA5O0D"},"metadata":{},"sourceType":"module"}