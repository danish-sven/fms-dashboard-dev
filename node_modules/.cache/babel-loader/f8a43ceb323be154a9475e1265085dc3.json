{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { log } from '@deck.gl/core';\nimport { Texture2D } from '@luma.gl/core';\nimport { equals } from '@math.gl/core';\nimport MaskPass from './mask-pass';\nimport { joinLayerBounds, getRenderBounds, makeViewport } from '../utils/projection-utils';\nexport default class MaskEffect {\n  constructor() {\n    _defineProperty(this, \"id\", 'mask-effect');\n    _defineProperty(this, \"props\", null);\n    _defineProperty(this, \"useInPicking\", true);\n    _defineProperty(this, \"order\", 0);\n    _defineProperty(this, \"dummyMaskMap\", void 0);\n    _defineProperty(this, \"channels\", []);\n    _defineProperty(this, \"masks\", null);\n    _defineProperty(this, \"maskPass\", void 0);\n    _defineProperty(this, \"maskMap\", void 0);\n    _defineProperty(this, \"lastViewport\", void 0);\n  }\n  preRender(gl, _ref) {\n    let {\n      layers,\n      layerFilter,\n      viewports,\n      onViewportActive,\n      views,\n      isPicking\n    } = _ref;\n    let didRender = false;\n    if (!this.dummyMaskMap) {\n      this.dummyMaskMap = new Texture2D(gl, {\n        width: 1,\n        height: 1\n      });\n    }\n    if (isPicking) {\n      return {\n        didRender\n      };\n    }\n    const maskLayers = layers.filter(l => l.props.visible && l.props.operation.includes('mask'));\n    if (maskLayers.length === 0) {\n      this.masks = null;\n      this.channels.length = 0;\n      return {\n        didRender\n      };\n    }\n    this.masks = {};\n    if (!this.maskPass) {\n      this.maskPass = new MaskPass(gl, {\n        id: 'default-mask'\n      });\n      this.maskMap = this.maskPass.maskMap;\n    }\n    const channelMap = this._sortMaskChannels(maskLayers);\n    const viewport = viewports[0];\n    const viewportChanged = !this.lastViewport || !this.lastViewport.equals(viewport);\n    if (viewport.resolution !== undefined) {\n      log.warn('MaskExtension is not supported in GlobeView')();\n      return {\n        didRender\n      };\n    }\n    for (const maskId in channelMap) {\n      const result = this._renderChannel(channelMap[maskId], {\n        layerFilter,\n        onViewportActive,\n        views,\n        viewport,\n        viewportChanged\n      });\n      didRender || (didRender = result);\n    }\n    return {\n      didRender\n    };\n  }\n  _renderChannel(channelInfo, _ref2) {\n    let {\n      layerFilter,\n      onViewportActive,\n      views,\n      viewport,\n      viewportChanged\n    } = _ref2;\n    let didRender = false;\n    const oldChannelInfo = this.channels[channelInfo.index];\n    if (!oldChannelInfo) {\n      return didRender;\n    }\n    const maskChanged = channelInfo === oldChannelInfo || channelInfo.layers.length !== oldChannelInfo.layers.length || channelInfo.layers.some((layer, i) => layer !== oldChannelInfo.layers[i] || layer.props.transitions) || channelInfo.layerBounds.some((b, i) => b !== oldChannelInfo.layerBounds[i]);\n    channelInfo.bounds = oldChannelInfo.bounds;\n    channelInfo.maskBounds = oldChannelInfo.maskBounds;\n    this.channels[channelInfo.index] = channelInfo;\n    if (maskChanged || viewportChanged) {\n      this.lastViewport = viewport;\n      const layerBounds = joinLayerBounds(channelInfo.layers, viewport);\n      channelInfo.bounds = layerBounds && getRenderBounds(layerBounds, viewport);\n      if (maskChanged || !equals(channelInfo.bounds, oldChannelInfo.bounds)) {\n        const {\n          maskPass,\n          maskMap\n        } = this;\n        const maskViewport = layerBounds && makeViewport({\n          bounds: channelInfo.bounds,\n          viewport,\n          width: maskMap.width,\n          height: maskMap.height,\n          border: 1\n        });\n        channelInfo.maskBounds = maskViewport ? maskViewport.getBounds() : [0, 0, 1, 1];\n        maskPass.render({\n          pass: 'mask',\n          channel: channelInfo.index,\n          layers: channelInfo.layers,\n          layerFilter,\n          viewports: maskViewport ? [maskViewport] : [],\n          onViewportActive,\n          views,\n          moduleParameters: {\n            devicePixelRatio: 1\n          }\n        });\n        didRender = true;\n      }\n    }\n    this.masks[channelInfo.id] = {\n      index: channelInfo.index,\n      bounds: channelInfo.maskBounds,\n      coordinateOrigin: channelInfo.coordinateOrigin,\n      coordinateSystem: channelInfo.coordinateSystem\n    };\n    return didRender;\n  }\n  _sortMaskChannels(maskLayers) {\n    const channelMap = {};\n    let channelCount = 0;\n    for (const layer of maskLayers) {\n      const {\n        id\n      } = layer.root;\n      let channelInfo = channelMap[id];\n      if (!channelInfo) {\n        if (++channelCount > 4) {\n          log.warn('Too many mask layers. The max supported is 4')();\n          continue;\n        }\n        channelInfo = {\n          id,\n          index: this.channels.findIndex(c => (c === null || c === void 0 ? void 0 : c.id) === id),\n          layers: [],\n          layerBounds: [],\n          coordinateOrigin: layer.root.props.coordinateOrigin,\n          coordinateSystem: layer.root.props.coordinateSystem\n        };\n        channelMap[id] = channelInfo;\n      }\n      channelInfo.layers.push(layer);\n      channelInfo.layerBounds.push(layer.getBounds());\n    }\n    for (let i = 0; i < 4; i++) {\n      const channelInfo = this.channels[i];\n      if (!channelInfo || !(channelInfo.id in channelMap)) {\n        this.channels[i] = null;\n      }\n    }\n    for (const maskId in channelMap) {\n      const channelInfo = channelMap[maskId];\n      if (channelInfo.index < 0) {\n        channelInfo.index = this.channels.findIndex(c => !c);\n        this.channels[channelInfo.index] = channelInfo;\n      }\n    }\n    return channelMap;\n  }\n  getModuleParameters() {\n    return {\n      maskMap: this.masks ? this.maskMap : this.dummyMaskMap,\n      maskChannels: this.masks\n    };\n  }\n  cleanup() {\n    if (this.dummyMaskMap) {\n      this.dummyMaskMap.delete();\n      this.dummyMaskMap = undefined;\n    }\n    if (this.maskPass) {\n      this.maskPass.delete();\n      this.maskPass = undefined;\n      this.maskMap = undefined;\n    }\n    this.lastViewport = undefined;\n    this.masks = null;\n    this.channels.length = 0;\n  }\n}","map":{"version":3,"names":["log","Texture2D","equals","MaskPass","joinLayerBounds","getRenderBounds","makeViewport","MaskEffect","constructor","_defineProperty","preRender","gl","_ref","layers","layerFilter","viewports","onViewportActive","views","isPicking","didRender","dummyMaskMap","width","height","maskLayers","filter","l","props","visible","operation","includes","length","masks","channels","maskPass","id","maskMap","channelMap","_sortMaskChannels","viewport","viewportChanged","lastViewport","resolution","undefined","warn","maskId","result","_renderChannel","channelInfo","_ref2","oldChannelInfo","index","maskChanged","some","layer","i","transitions","layerBounds","b","bounds","maskBounds","maskViewport","border","getBounds","render","pass","channel","moduleParameters","devicePixelRatio","coordinateOrigin","coordinateSystem","channelCount","root","findIndex","c","push","getModuleParameters","maskChannels","cleanup","delete"],"sources":["../../../src/mask/mask-effect.ts"],"sourcesContent":["import {Layer, Viewport, Effect, PreRenderOptions, CoordinateSystem, log} from '@deck.gl/core';\nimport {Texture2D} from '@luma.gl/core';\nimport {equals} from '@math.gl/core';\nimport MaskPass from './mask-pass';\nimport {joinLayerBounds, getRenderBounds, makeViewport, Bounds} from '../utils/projection-utils';\n// import {debugFBO} from '../utils/debug';\n\ntype Mask = {\n  /** The channel index */\n  index: number;\n  bounds: Bounds;\n  coordinateOrigin: [number, number, number];\n  coordinateSystem: CoordinateSystem;\n};\n\ntype Channel = {\n  id: string;\n  index: number;\n  layers: Layer[];\n  bounds: Bounds | null;\n  maskBounds: Bounds;\n  layerBounds: Bounds[];\n  coordinateOrigin: [number, number, number];\n  coordinateSystem: CoordinateSystem;\n};\n\nexport type MaskPreRenderStats = {\n  didRender: boolean;\n};\n\n// Class to manage mask effect\nexport default class MaskEffect implements Effect {\n  id = 'mask-effect';\n  props = null;\n  useInPicking = true;\n  order = 0;\n\n  private dummyMaskMap?: Texture2D;\n  private channels: (Channel | null)[] = [];\n  private masks: Record<string, Mask> | null = null;\n  private maskPass?: MaskPass;\n  private maskMap?: Texture2D;\n  private lastViewport?: Viewport;\n\n  preRender(\n    gl: WebGLRenderingContext,\n    {layers, layerFilter, viewports, onViewportActive, views, isPicking}: PreRenderOptions\n  ): MaskPreRenderStats {\n    let didRender = false;\n    if (!this.dummyMaskMap) {\n      this.dummyMaskMap = new Texture2D(gl, {\n        width: 1,\n        height: 1\n      });\n    }\n\n    if (isPicking) {\n      // Do not update on picking pass\n      return {didRender};\n    }\n\n    const maskLayers = layers.filter(l => l.props.visible && l.props.operation.includes('mask'));\n    if (maskLayers.length === 0) {\n      this.masks = null;\n      this.channels.length = 0;\n      return {didRender};\n    }\n    this.masks = {};\n\n    if (!this.maskPass) {\n      this.maskPass = new MaskPass(gl, {id: 'default-mask'});\n      this.maskMap = this.maskPass.maskMap;\n    }\n\n    // Map layers to channels\n    const channelMap = this._sortMaskChannels(maskLayers);\n    // TODO - support multiple views\n    const viewport = viewports[0];\n    const viewportChanged = !this.lastViewport || !this.lastViewport.equals(viewport);\n\n    if (viewport.resolution !== undefined) {\n      log.warn('MaskExtension is not supported in GlobeView')();\n      return {didRender};\n    }\n\n    for (const maskId in channelMap) {\n      const result = this._renderChannel(channelMap[maskId], {\n        layerFilter,\n        onViewportActive,\n        views,\n        viewport,\n        viewportChanged\n      });\n      didRender ||= result;\n    }\n\n    // debugFBO(this.maskMap, {opaque: true});\n    return {didRender};\n  }\n\n  private _renderChannel(\n    channelInfo: Channel,\n    {\n      layerFilter,\n      onViewportActive,\n      views,\n      viewport,\n      viewportChanged\n    }: {\n      layerFilter: PreRenderOptions['layerFilter'];\n      onViewportActive: PreRenderOptions['onViewportActive'];\n      views: PreRenderOptions['views'];\n      viewport: Viewport;\n      viewportChanged: boolean;\n    }\n  ): boolean {\n    let didRender = false;\n    const oldChannelInfo = this.channels[channelInfo.index];\n    if (!oldChannelInfo) {\n      return didRender;\n    }\n\n    const maskChanged =\n      // If a channel is new\n      channelInfo === oldChannelInfo ||\n      // If sublayers have changed\n      channelInfo.layers.length !== oldChannelInfo.layers.length ||\n      channelInfo.layers.some(\n        (layer, i) =>\n          // Layer instance is updated\n          // Layer props might have changed\n          // Undetermined props could have an effect on the output geometry of a mask layer,\n          // for example getRadius+updateTriggers, radiusScale, modelMatrix\n          layer !== oldChannelInfo.layers[i] ||\n          // Some prop is in transition\n          layer.props.transitions\n      ) ||\n      // If a sublayer's positions have been updated, the cached bounds will change shallowly\n      channelInfo.layerBounds.some((b, i) => b !== oldChannelInfo.layerBounds[i]);\n\n    channelInfo.bounds = oldChannelInfo.bounds;\n    channelInfo.maskBounds = oldChannelInfo.maskBounds;\n    this.channels[channelInfo.index] = channelInfo;\n\n    if (maskChanged || viewportChanged) {\n      // Recalculate mask bounds\n      this.lastViewport = viewport;\n\n      const layerBounds = joinLayerBounds(channelInfo.layers, viewport);\n      channelInfo.bounds = layerBounds && getRenderBounds(layerBounds, viewport);\n\n      if (maskChanged || !equals(channelInfo.bounds, oldChannelInfo.bounds)) {\n        // Rerender mask FBO\n        const {maskPass, maskMap} = this;\n\n        const maskViewport =\n          layerBounds &&\n          makeViewport({\n            bounds: channelInfo.bounds!,\n            viewport,\n            width: maskMap.width,\n            height: maskMap.height,\n            border: 1\n          });\n\n        channelInfo.maskBounds = maskViewport ? maskViewport.getBounds() : [0, 0, 1, 1];\n\n        // @ts-ignore (2532) This method is only called from preRender where maskPass is defined\n        maskPass.render({\n          pass: 'mask',\n          channel: channelInfo.index,\n          layers: channelInfo.layers,\n          layerFilter,\n          viewports: maskViewport ? [maskViewport] : [],\n          onViewportActive,\n          views,\n          moduleParameters: {\n            devicePixelRatio: 1\n          }\n        });\n\n        didRender = true;\n      }\n    }\n\n    // @ts-ignore (2532) This method is only called from preRender where masks is defined\n    this.masks[channelInfo.id] = {\n      index: channelInfo.index,\n      bounds: channelInfo.maskBounds,\n      coordinateOrigin: channelInfo.coordinateOrigin,\n      coordinateSystem: channelInfo.coordinateSystem\n    };\n\n    return didRender;\n  }\n\n  /**\n   * Find a channel to render each mask into\n   * If a maskId already exists, diff and update the existing channel\n   * Otherwise replace a removed mask\n   * Otherwise create a new channel\n   * Returns a map from mask layer id to channel info\n   */\n  private _sortMaskChannels(maskLayers: Layer[]): Record<string, Channel> {\n    const channelMap = {};\n    let channelCount = 0;\n    for (const layer of maskLayers) {\n      const {id} = layer.root;\n      let channelInfo = channelMap[id];\n      if (!channelInfo) {\n        if (++channelCount > 4) {\n          log.warn('Too many mask layers. The max supported is 4')();\n          continue; // eslint-disable-line no-continue\n        }\n        channelInfo = {\n          id,\n          index: this.channels.findIndex(c => c?.id === id),\n          layers: [],\n          layerBounds: [],\n          coordinateOrigin: layer.root.props.coordinateOrigin,\n          coordinateSystem: layer.root.props.coordinateSystem\n        };\n        channelMap[id] = channelInfo;\n      }\n      channelInfo.layers.push(layer);\n      channelInfo.layerBounds.push(layer.getBounds());\n    }\n\n    for (let i = 0; i < 4; i++) {\n      const channelInfo = this.channels[i];\n      if (!channelInfo || !(channelInfo.id in channelMap)) {\n        // The mask id at this channel no longer exists\n        this.channels[i] = null;\n      }\n    }\n\n    for (const maskId in channelMap) {\n      const channelInfo = channelMap[maskId];\n\n      if (channelInfo.index < 0) {\n        channelInfo.index = this.channels.findIndex(c => !c);\n        this.channels[channelInfo.index] = channelInfo;\n      }\n    }\n    return channelMap;\n  }\n\n  getModuleParameters(): {\n    maskMap: Texture2D;\n    maskChannels: Record<string, Mask> | null;\n  } {\n    return {\n      maskMap: this.masks ? this.maskMap : this.dummyMaskMap,\n      maskChannels: this.masks\n    };\n  }\n\n  cleanup(): void {\n    if (this.dummyMaskMap) {\n      this.dummyMaskMap.delete();\n      this.dummyMaskMap = undefined;\n    }\n\n    if (this.maskPass) {\n      this.maskPass.delete();\n      this.maskPass = undefined;\n      this.maskMap = undefined;\n    }\n\n    this.lastViewport = undefined;\n    this.masks = null;\n    this.channels.length = 0;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}