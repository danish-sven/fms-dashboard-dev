{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { createRenderTarget } from './utils';\nimport { joinLayerBounds, makeViewport, getRenderBounds } from '../utils/projection-utils';\nexport class TerrainCover {\n  constructor(targetLayer) {\n    _defineProperty(this, \"isDirty\", true);\n    _defineProperty(this, \"targetLayer\", void 0);\n    _defineProperty(this, \"renderViewport\", null);\n    _defineProperty(this, \"bounds\", null);\n    _defineProperty(this, \"fbo\", void 0);\n    _defineProperty(this, \"pickingFbo\", void 0);\n    _defineProperty(this, \"layers\", []);\n    _defineProperty(this, \"tile\", void 0);\n    _defineProperty(this, \"targetBounds\", null);\n    _defineProperty(this, \"targetBoundsCommon\", null);\n    this.targetLayer = targetLayer;\n    this.tile = getTile(targetLayer);\n  }\n  get id() {\n    return this.targetLayer.id;\n  }\n  get isActive() {\n    return Boolean(this.targetLayer.getCurrentLayer());\n  }\n  shouldUpdate(_ref) {\n    let {\n      targetLayer,\n      viewport,\n      layers,\n      layerNeedsRedraw\n    } = _ref;\n    if (targetLayer) {\n      this.targetLayer = targetLayer;\n    }\n    const sizeChanged = viewport ? this._updateViewport(viewport) : false;\n    let layersChanged = layers ? this._updateLayers(layers) : false;\n    if (layerNeedsRedraw) {\n      for (const id of this.layers) {\n        if (layerNeedsRedraw[id]) {\n          layersChanged = true;\n          break;\n        }\n      }\n    }\n    return layersChanged || sizeChanged;\n  }\n  _updateLayers(layers) {\n    let needsRedraw = false;\n    layers = this.tile ? getIntersectingLayers(this.tile, layers) : layers;\n    if (layers.length !== this.layers.length) {\n      needsRedraw = true;\n    } else {\n      for (let i = 0; i < layers.length; i++) {\n        const id = layers[i].id;\n        if (id !== this.layers[i]) {\n          needsRedraw = true;\n          break;\n        }\n      }\n    }\n    if (needsRedraw) {\n      this.layers = layers.map(layer => layer.id);\n    }\n    return needsRedraw;\n  }\n  _updateViewport(viewport) {\n    const targetLayer = this.targetLayer;\n    let shouldRedraw = false;\n    if (this.tile && 'boundingBox' in this.tile) {\n      if (!this.targetBounds) {\n        shouldRedraw = true;\n        this.targetBounds = this.tile.boundingBox;\n        const bottomLeftCommon = viewport.projectPosition(this.targetBounds[0]);\n        const topRightCommon = viewport.projectPosition(this.targetBounds[1]);\n        this.targetBoundsCommon = [bottomLeftCommon[0], bottomLeftCommon[1], topRightCommon[0], topRightCommon[1]];\n      }\n    } else if (this.targetBounds !== targetLayer.getBounds()) {\n      shouldRedraw = true;\n      this.targetBounds = targetLayer.getBounds();\n      this.targetBoundsCommon = joinLayerBounds([targetLayer], viewport);\n    }\n    if (!this.targetBoundsCommon) {\n      return false;\n    }\n    const newZoom = Math.ceil(viewport.zoom + 0.5);\n    if (this.tile) {\n      this.bounds = this.targetBoundsCommon;\n    } else {\n      var _this$renderViewport;\n      const oldZoom = (_this$renderViewport = this.renderViewport) === null || _this$renderViewport === void 0 ? void 0 : _this$renderViewport.zoom;\n      shouldRedraw = shouldRedraw || newZoom !== oldZoom;\n      const newBounds = getRenderBounds(this.targetBoundsCommon, viewport);\n      const oldBounds = this.bounds;\n      shouldRedraw = shouldRedraw || !oldBounds || newBounds.some((x, i) => x !== oldBounds[i]);\n      this.bounds = newBounds;\n    }\n    if (shouldRedraw) {\n      this.renderViewport = makeViewport({\n        bounds: this.bounds,\n        zoom: newZoom,\n        viewport\n      });\n    }\n    return shouldRedraw;\n  }\n  getRenderFramebuffer() {\n    if (!this.renderViewport || this.layers.length === 0) {\n      return null;\n    }\n    if (!this.fbo) {\n      this.fbo = createRenderTarget(this.targetLayer.context.gl, {\n        id: this.id\n      });\n    }\n    return this.fbo;\n  }\n  getPickingFramebuffer() {\n    if (!this.renderViewport || this.layers.length === 0 && !this.targetLayer.props.pickable) {\n      return null;\n    }\n    if (!this.pickingFbo) {\n      this.pickingFbo = createRenderTarget(this.targetLayer.context.gl, {\n        id: \"\".concat(this.id, \"-picking\")\n      });\n    }\n    return this.pickingFbo;\n  }\n  filterLayers(layers) {\n    return layers.filter(_ref2 => {\n      let {\n        id\n      } = _ref2;\n      return this.layers.includes(id);\n    });\n  }\n  delete() {\n    const {\n      fbo,\n      pickingFbo\n    } = this;\n    if (fbo) {\n      fbo.texture.delete();\n      fbo.delete();\n    }\n    if (pickingFbo) {\n      pickingFbo.texture.delete();\n      pickingFbo.delete();\n    }\n  }\n}\nfunction getIntersectingLayers(sourceTile, layers) {\n  return layers.filter(layer => {\n    const tile = getTile(layer);\n    if (tile) {\n      return intersect(sourceTile.boundingBox, tile.boundingBox);\n    }\n    return true;\n  });\n}\nfunction getTile(layer) {\n  while (layer) {\n    const {\n      tile\n    } = layer.props;\n    if (tile) {\n      return tile;\n    }\n    layer = layer.parent;\n  }\n  return null;\n}\nfunction intersect(b1, b2) {\n  if (b1 && b2) {\n    return b1[0][0] < b2[1][0] && b2[0][0] < b1[1][0] && b1[0][1] < b2[1][1] && b2[0][1] < b1[1][1];\n  }\n  return false;\n}","map":{"version":3,"names":["createRenderTarget","joinLayerBounds","makeViewport","getRenderBounds","TerrainCover","constructor","targetLayer","_defineProperty","tile","getTile","id","isActive","Boolean","getCurrentLayer","shouldUpdate","_ref","viewport","layers","layerNeedsRedraw","sizeChanged","_updateViewport","layersChanged","_updateLayers","needsRedraw","getIntersectingLayers","length","i","map","layer","shouldRedraw","targetBounds","boundingBox","bottomLeftCommon","projectPosition","topRightCommon","targetBoundsCommon","getBounds","newZoom","Math","ceil","zoom","bounds","_this$renderViewport","oldZoom","renderViewport","newBounds","oldBounds","some","x","getRenderFramebuffer","fbo","context","gl","getPickingFramebuffer","props","pickable","pickingFbo","concat","filterLayers","filter","_ref2","includes","delete","texture","sourceTile","intersect","parent","b1","b2"],"sources":["../../../src/terrain/terrain-cover.ts"],"sourcesContent":["import {Framebuffer} from '@luma.gl/core';\n\nimport type {Layer, Viewport} from '@deck.gl/core';\n\nimport {createRenderTarget} from './utils';\nimport {joinLayerBounds, makeViewport, getRenderBounds, Bounds} from '../utils/projection-utils';\n\ntype TileHeader = {\n  boundingBox: [min: number[], max: number[]];\n};\n\n/**\n * Manages the lifecycle of the terrain cover (draped textures over a terrain mesh).\n * One terrain cover is created for each unique terrain layer (primitive layer with operation:terrain).\n * It is updated when the terrain source layer's mesh changes or when any of the terrainDrawMode:drape\n * layers requires redraw.\n * During the draw call of a terrain layer, the drape texture is overlaid on top of the layer's own color.\n */\nexport class TerrainCover {\n  isDirty: boolean = true;\n  /** The terrain layer that this instance belongs to */\n  targetLayer: Layer;\n  /** Viewport used to draw into the texture */\n  renderViewport: Viewport | null = null;\n  /** Bounds of the terrain cover texture, in cartesian space */\n  bounds: Bounds | null = null;\n\n  private fbo?: Framebuffer;\n  private pickingFbo?: Framebuffer;\n  private layers: string[] = [];\n  private tile: TileHeader | null;\n  /** Cached version of targetLayer.getBounds() */\n  private targetBounds: [number[], number[]] | null = null;\n  /** targetBounds in cartesian space */\n  private targetBoundsCommon: Bounds | null = null;\n\n  constructor(targetLayer: Layer) {\n    this.targetLayer = targetLayer;\n    this.tile = getTile(targetLayer);\n  }\n\n  get id() {\n    return this.targetLayer.id;\n  }\n\n  /** returns true if the target layer is still in use (i.e. not finalized) */\n  get isActive(): boolean {\n    return Boolean(this.targetLayer.getCurrentLayer());\n  }\n\n  shouldUpdate({\n    targetLayer,\n    viewport,\n    layers,\n    layerNeedsRedraw\n  }: {\n    targetLayer?: Layer;\n    viewport?: Viewport;\n    layers?: Layer[];\n    layerNeedsRedraw?: Record<string, boolean>;\n  }): boolean {\n    if (targetLayer) {\n      this.targetLayer = targetLayer;\n    }\n    const sizeChanged = viewport ? this._updateViewport(viewport) : false;\n\n    let layersChanged = layers ? this._updateLayers(layers) : false;\n\n    if (layerNeedsRedraw) {\n      for (const id of this.layers) {\n        if (layerNeedsRedraw[id]) {\n          layersChanged = true;\n          // console.log('layer needs redraw', id);\n          break;\n        }\n      }\n    }\n\n    return layersChanged || sizeChanged;\n  }\n\n  /** Compare layers with the last version. Only rerender if necessary. */\n  private _updateLayers(layers: Layer[]): boolean {\n    let needsRedraw = false;\n    layers = this.tile ? getIntersectingLayers(this.tile, layers) : layers;\n\n    if (layers.length !== this.layers.length) {\n      needsRedraw = true;\n      // console.log('layers count changed', this.layers.length, '>>', layers.length);\n    } else {\n      for (let i = 0; i < layers.length; i++) {\n        const id = layers[i].id;\n        if (id !== this.layers[i]) {\n          needsRedraw = true;\n          // console.log('layer added/removed', id);\n          break;\n        }\n      }\n    }\n    if (needsRedraw) {\n      this.layers = layers.map(layer => layer.id);\n    }\n    return needsRedraw;\n  }\n\n  /** Compare viewport and terrain bounds with the last version. Only rerender if necesary. */\n  private _updateViewport(viewport: Viewport): boolean {\n    const targetLayer = this.targetLayer;\n    let shouldRedraw = false;\n\n    if (this.tile && 'boundingBox' in this.tile) {\n      if (!this.targetBounds) {\n        shouldRedraw = true;\n        this.targetBounds = this.tile.boundingBox;\n\n        const bottomLeftCommon = viewport.projectPosition(this.targetBounds[0]);\n        const topRightCommon = viewport.projectPosition(this.targetBounds[1]);\n        this.targetBoundsCommon = [\n          bottomLeftCommon[0],\n          bottomLeftCommon[1],\n          topRightCommon[0],\n          topRightCommon[1]\n        ];\n      }\n    } else if (this.targetBounds !== targetLayer.getBounds()) {\n      // console.log('bounds changed', this.bounds, '>>', newBounds);\n      shouldRedraw = true;\n      this.targetBounds = targetLayer.getBounds();\n      this.targetBoundsCommon = joinLayerBounds([targetLayer], viewport);\n    }\n\n    if (!this.targetBoundsCommon) {\n      return false;\n    }\n\n    const newZoom = Math.ceil(viewport.zoom + 0.5);\n    // If the terrain layer is bound to a tile, always render a texture that cover the whole tile.\n    // Otherwise, use the smaller of layer bounds and the viewport bounds.\n    if (this.tile) {\n      this.bounds = this.targetBoundsCommon;\n    } else {\n      const oldZoom = this.renderViewport?.zoom;\n      shouldRedraw = shouldRedraw || newZoom !== oldZoom;\n      const newBounds = getRenderBounds(this.targetBoundsCommon, viewport);\n      const oldBounds = this.bounds;\n      shouldRedraw = shouldRedraw || !oldBounds || newBounds.some((x, i) => x !== oldBounds[i]);\n      this.bounds = newBounds;\n    }\n\n    if (shouldRedraw) {\n      this.renderViewport = makeViewport({\n        bounds: this.bounds,\n        zoom: newZoom,\n        viewport\n      });\n    }\n\n    return shouldRedraw;\n  }\n\n  getRenderFramebuffer(): Framebuffer | null {\n    if (!this.renderViewport || this.layers.length === 0) {\n      return null;\n    }\n    if (!this.fbo) {\n      this.fbo = createRenderTarget(this.targetLayer.context.gl, {id: this.id});\n    }\n    return this.fbo;\n  }\n\n  getPickingFramebuffer(): Framebuffer | null {\n    if (!this.renderViewport || (this.layers.length === 0 && !this.targetLayer.props.pickable)) {\n      return null;\n    }\n    if (!this.pickingFbo) {\n      this.pickingFbo = createRenderTarget(this.targetLayer.context.gl, {id: `${this.id}-picking`});\n    }\n    return this.pickingFbo;\n  }\n\n  filterLayers(layers: Layer[]) {\n    return layers.filter(({id}) => this.layers.includes(id));\n  }\n\n  delete() {\n    const {fbo, pickingFbo} = this;\n    if (fbo) {\n      fbo.texture.delete();\n      fbo.delete();\n    }\n    if (pickingFbo) {\n      pickingFbo.texture.delete();\n      pickingFbo.delete();\n    }\n  }\n}\n\n/**\n * Remove layers that do not overlap with the current terrain cover.\n * This implementation only has effect when a TileLayer is overlaid on top of a TileLayer\n */\nfunction getIntersectingLayers(sourceTile: TileHeader, layers: Layer[]): Layer[] {\n  return layers.filter(layer => {\n    const tile = getTile(layer);\n    if (tile) {\n      return intersect(sourceTile.boundingBox, tile.boundingBox);\n    }\n    return true;\n  });\n}\n\n/** If layer is the descendent of a TileLayer, return the corresponding tile. */\nfunction getTile(layer: Layer): TileHeader | null {\n  while (layer) {\n    // @ts-expect-error tile may not exist\n    const {tile} = layer.props;\n    if (tile) {\n      return tile;\n    }\n    layer = layer.parent as Layer;\n  }\n  return null;\n}\n\nfunction intersect(b1?: [number[], number[]], b2?: [number[], number[]]): boolean {\n  if (b1 && b2) {\n    return b1[0][0] < b2[1][0] && b2[0][0] < b1[1][0] && b1[0][1] < b2[1][1] && b2[0][1] < b1[1][1];\n  }\n  return false;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}