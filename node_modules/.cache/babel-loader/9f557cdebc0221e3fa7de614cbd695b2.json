{"ast":null,"code":"import { project } from '@deck.gl/core';\nexport const TERRAIN_MODE = {\n  NONE: 0,\n  WRITE_HEIGHT_MAP: 1,\n  USE_HEIGHT_MAP: 2,\n  USE_COVER: 3,\n  USE_COVER_ONLY: 4,\n  SKIP: 5\n};\nconst TERRAIN_MODE_CONSTANTS = Object.keys(TERRAIN_MODE).map(key => \"const float TERRAIN_MODE_\".concat(key, \" = \").concat(TERRAIN_MODE[key], \".0;\")).join('\\n');\nexport const terrainModule = {\n  name: 'terrain',\n  dependencies: [project],\n  inject: {\n    'vs:#decl': \"\\nuniform float terrain_mode;\\nuniform sampler2D terrain_map;\\nuniform vec4 terrain_bounds;\\nvarying vec3 commonPos;\\n\".concat(TERRAIN_MODE_CONSTANTS, \"\\n    \"),\n    'vs:#main-start': \"\\nif (terrain_mode == TERRAIN_MODE_SKIP) {\\n  gl_Position = vec4(0.0);\\n  return;\\n}\\n\",\n    'vs:DECKGL_FILTER_GL_POSITION': \"\\ncommonPos = geometry.position.xyz;\\nif (terrain_mode == TERRAIN_MODE_WRITE_HEIGHT_MAP) {\\n  vec2 texCoords = (commonPos.xy - terrain_bounds.xy) / terrain_bounds.zw;\\n  position = vec4(texCoords * 2.0 - 1.0, 0.0, 1.0);\\n  commonPos.z += project_uCommonOrigin.z;\\n}\\nif (terrain_mode == TERRAIN_MODE_USE_HEIGHT_MAP) {\\n  vec3 anchor = geometry.worldPosition;\\n  anchor.z = 0.0;\\n  vec3 anchorCommon = project_position(anchor);\\n  vec2 texCoords = (anchorCommon.xy - terrain_bounds.xy) / terrain_bounds.zw;\\n  if (texCoords.x >= 0.0 && texCoords.y >= 0.0 && texCoords.x <= 1.0 && texCoords.y <= 1.0) {\\n    float terrainZ = texture2D(terrain_map, texCoords).r;\\n    geometry.position.z += terrainZ;\\n    position = project_common_position_to_clipspace(geometry.position);\\n  }\\n}\\n    \",\n    'fs:#decl': \"\\nuniform float terrain_mode;\\nuniform sampler2D terrain_map;\\nuniform vec4 terrain_bounds;\\nvarying vec3 commonPos;\\n\".concat(TERRAIN_MODE_CONSTANTS, \"\\n    \"),\n    'fs:#main-start': \"\\nif (terrain_mode == TERRAIN_MODE_WRITE_HEIGHT_MAP) {\\n  gl_FragColor = vec4(commonPos.z, 0.0, 0.0, 1.0);\\n  return;\\n}\\n    \",\n    'fs:DECKGL_FILTER_COLOR': \"\\nif ((terrain_mode == TERRAIN_MODE_USE_COVER) || (terrain_mode == TERRAIN_MODE_USE_COVER_ONLY)) {\\n  vec2 texCoords = (commonPos.xy - terrain_bounds.xy) / terrain_bounds.zw;\\n  vec4 pixel = texture2D(terrain_map, texCoords);\\n  if (terrain_mode == TERRAIN_MODE_USE_COVER_ONLY) {\\n    color = pixel;\\n  } else {\\n    // pixel is premultiplied\\n    color = pixel + color * (1.0 - pixel.a);\\n  }\\n  return;\\n}\\n    \"\n  },\n  getUniforms: function () {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let uniforms = arguments.length > 1 ? arguments[1] : undefined;\n    if ('dummyHeightMap' in opts) {\n      const {\n        drawToTerrainHeightMap,\n        heightMap,\n        heightMapBounds,\n        dummyHeightMap,\n        terrainCover,\n        useTerrainHeightMap,\n        terrainSkipRender\n      } = opts;\n      const {\n        project_uCommonOrigin\n      } = uniforms;\n      let mode = terrainSkipRender ? TERRAIN_MODE.SKIP : TERRAIN_MODE.NONE;\n      let sampler = dummyHeightMap;\n      let bounds = null;\n      if (drawToTerrainHeightMap) {\n        mode = TERRAIN_MODE.WRITE_HEIGHT_MAP;\n        bounds = heightMapBounds;\n      } else if (useTerrainHeightMap && heightMap) {\n        mode = TERRAIN_MODE.USE_HEIGHT_MAP;\n        sampler = heightMap;\n        bounds = heightMapBounds;\n      } else if (terrainCover) {\n        const isPicking = opts.pickingActive;\n        sampler = isPicking ? terrainCover.getPickingFramebuffer() : terrainCover.getRenderFramebuffer();\n        if (isPicking) {\n          mode = TERRAIN_MODE.SKIP;\n        }\n        if (sampler) {\n          mode = mode === TERRAIN_MODE.SKIP ? TERRAIN_MODE.USE_COVER_ONLY : TERRAIN_MODE.USE_COVER;\n          bounds = terrainCover.bounds;\n        } else {\n          sampler = dummyHeightMap;\n        }\n      }\n      return {\n        terrain_mode: mode,\n        terrain_map: sampler,\n        terrain_bounds: bounds ? [bounds[0] - project_uCommonOrigin[0], bounds[1] - project_uCommonOrigin[1], bounds[2] - bounds[0], bounds[3] - bounds[1]] : [0, 0, 0, 0]\n      };\n    }\n    return null;\n  }\n};","map":{"version":3,"names":["project","TERRAIN_MODE","NONE","WRITE_HEIGHT_MAP","USE_HEIGHT_MAP","USE_COVER","USE_COVER_ONLY","SKIP","TERRAIN_MODE_CONSTANTS","Object","keys","map","key","concat","join","terrainModule","name","dependencies","inject","getUniforms","opts","arguments","length","undefined","uniforms","drawToTerrainHeightMap","heightMap","heightMapBounds","dummyHeightMap","terrainCover","useTerrainHeightMap","terrainSkipRender","project_uCommonOrigin","mode","sampler","bounds","isPicking","pickingActive","getPickingFramebuffer","getRenderFramebuffer","terrain_mode","terrain_map","terrain_bounds"],"sources":["../../../src/terrain/shader-module.ts"],"sourcesContent":["/* eslint-disable camelcase */\n\nimport {project} from '@deck.gl/core';\nimport type {_ShaderModule as ShaderModule} from '@deck.gl/core';\n\nimport type {Texture2D} from '@luma.gl/core';\nimport type {Bounds} from '../utils/projection-utils';\nimport type {TerrainCover} from './terrain-cover';\n\n/** Module parameters expected by the terrain shader module */\nexport type TerrainModuleSettings = {\n  pickingActive?: boolean;\n  heightMap: Texture2D | null;\n  heightMapBounds?: Bounds | null;\n  dummyHeightMap: Texture2D;\n  terrainCover?: TerrainCover | null;\n  drawToTerrainHeightMap?: boolean;\n  useTerrainHeightMap?: boolean;\n  terrainSkipRender?: boolean;\n};\n\n/** A model can have one of the following modes */\nexport const TERRAIN_MODE = {\n  NONE: 0,\n  /** A terrain layer rendering encoded ground elevation into the height map */\n  WRITE_HEIGHT_MAP: 1,\n  /** An offset layer reading encoded ground elevation from the height map */\n  USE_HEIGHT_MAP: 2,\n  /** A terrain layer rendering to screen, using the cover fbo overlaid with its own texture */\n  USE_COVER: 3,\n  /** A terrain layer rendering to screen, using the cover fbo as texture */\n  USE_COVER_ONLY: 4,\n  /** Draped layer is rendered into a texture, and never to screen */\n  SKIP: 5\n};\n\nconst TERRAIN_MODE_CONSTANTS = Object.keys(TERRAIN_MODE)\n  .map(key => `const float TERRAIN_MODE_${key} = ${TERRAIN_MODE[key]}.0;`)\n  .join('\\n');\n\nexport const terrainModule = {\n  name: 'terrain',\n  dependencies: [project],\n  inject: {\n    'vs:#decl': `\nuniform float terrain_mode;\nuniform sampler2D terrain_map;\nuniform vec4 terrain_bounds;\nvarying vec3 commonPos;\n${TERRAIN_MODE_CONSTANTS}\n    `,\n    'vs:#main-start': `\nif (terrain_mode == TERRAIN_MODE_SKIP) {\n  gl_Position = vec4(0.0);\n  return;\n}\n`,\n    'vs:DECKGL_FILTER_GL_POSITION': `\ncommonPos = geometry.position.xyz;\nif (terrain_mode == TERRAIN_MODE_WRITE_HEIGHT_MAP) {\n  vec2 texCoords = (commonPos.xy - terrain_bounds.xy) / terrain_bounds.zw;\n  position = vec4(texCoords * 2.0 - 1.0, 0.0, 1.0);\n  commonPos.z += project_uCommonOrigin.z;\n}\nif (terrain_mode == TERRAIN_MODE_USE_HEIGHT_MAP) {\n  vec3 anchor = geometry.worldPosition;\n  anchor.z = 0.0;\n  vec3 anchorCommon = project_position(anchor);\n  vec2 texCoords = (anchorCommon.xy - terrain_bounds.xy) / terrain_bounds.zw;\n  if (texCoords.x >= 0.0 && texCoords.y >= 0.0 && texCoords.x <= 1.0 && texCoords.y <= 1.0) {\n    float terrainZ = texture2D(terrain_map, texCoords).r;\n    geometry.position.z += terrainZ;\n    position = project_common_position_to_clipspace(geometry.position);\n  }\n}\n    `,\n    'fs:#decl': `\nuniform float terrain_mode;\nuniform sampler2D terrain_map;\nuniform vec4 terrain_bounds;\nvarying vec3 commonPos;\n${TERRAIN_MODE_CONSTANTS}\n    `,\n    'fs:#main-start': `\nif (terrain_mode == TERRAIN_MODE_WRITE_HEIGHT_MAP) {\n  gl_FragColor = vec4(commonPos.z, 0.0, 0.0, 1.0);\n  return;\n}\n    `,\n    'fs:DECKGL_FILTER_COLOR': `\nif ((terrain_mode == TERRAIN_MODE_USE_COVER) || (terrain_mode == TERRAIN_MODE_USE_COVER_ONLY)) {\n  vec2 texCoords = (commonPos.xy - terrain_bounds.xy) / terrain_bounds.zw;\n  vec4 pixel = texture2D(terrain_map, texCoords);\n  if (terrain_mode == TERRAIN_MODE_USE_COVER_ONLY) {\n    color = pixel;\n  } else {\n    // pixel is premultiplied\n    color = pixel + color * (1.0 - pixel.a);\n  }\n  return;\n}\n    `\n  },\n  // eslint-disable-next-line complexity\n  getUniforms: (opts = {}, uniforms) => {\n    if ('dummyHeightMap' in opts) {\n      const {\n        drawToTerrainHeightMap,\n        heightMap,\n        heightMapBounds,\n        dummyHeightMap,\n        terrainCover,\n        useTerrainHeightMap,\n        terrainSkipRender\n      } = opts;\n      const {project_uCommonOrigin} = uniforms;\n\n      let mode: number = terrainSkipRender ? TERRAIN_MODE.SKIP : TERRAIN_MODE.NONE;\n      // height map if case USE_HEIGHT_MAP, terrain cover if USE_COVER, otherwise empty\n      let sampler: Texture2D = dummyHeightMap;\n      // height map bounds if case USE_HEIGHT_MAP, terrain cover bounds if USE_COVER, otherwise null\n      let bounds: number[] | null = null;\n      if (drawToTerrainHeightMap) {\n        mode = TERRAIN_MODE.WRITE_HEIGHT_MAP;\n        bounds = heightMapBounds!;\n      } else if (useTerrainHeightMap && heightMap) {\n        mode = TERRAIN_MODE.USE_HEIGHT_MAP;\n        sampler = heightMap;\n        bounds = heightMapBounds!;\n      } else if (terrainCover) {\n        // This is a terrain layer\n        const isPicking = opts.pickingActive;\n        sampler = isPicking\n          ? terrainCover.getPickingFramebuffer()\n          : terrainCover.getRenderFramebuffer();\n        if (isPicking) {\n          // Never render the layer itself in picking pass\n          mode = TERRAIN_MODE.SKIP;\n        }\n        if (sampler) {\n          mode = mode === TERRAIN_MODE.SKIP ? TERRAIN_MODE.USE_COVER_ONLY : TERRAIN_MODE.USE_COVER;\n          bounds = terrainCover.bounds;\n        } else {\n          sampler = dummyHeightMap;\n        }\n      }\n\n      /* eslint-disable camelcase */\n      return {\n        terrain_mode: mode,\n        terrain_map: sampler,\n        // Convert bounds to the common space, as [minX, minY, width, height]\n        terrain_bounds: bounds\n          ? [\n              bounds[0] - project_uCommonOrigin[0],\n              bounds[1] - project_uCommonOrigin[1],\n              bounds[2] - bounds[0],\n              bounds[3] - bounds[1]\n            ]\n          : [0, 0, 0, 0]\n      };\n    }\n    return null;\n  }\n} as ShaderModule<TerrainModuleSettings>;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}