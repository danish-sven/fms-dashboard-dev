{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { CompositeLayer, COORDINATE_SYSTEM, _deepEqual as deepEqual } from '@deck.gl/core';\nimport { BitmapLayer } from '@deck.gl/layers';\nimport { ImageSource, createImageSource } from '@loaders.gl/wms';\nimport { WGS84ToPseudoMercator } from './utils';\nconst defaultProps = {\n  id: 'imagery-layer',\n  data: '',\n  serviceType: 'auto',\n  srs: 'auto',\n  layers: {\n    type: 'array',\n    compare: true,\n    value: []\n  },\n  onMetadataLoad: {\n    type: 'function',\n    value: () => {}\n  },\n  onMetadataLoadError: {\n    type: 'function',\n    value: console.error\n  },\n  onImageLoadStart: {\n    type: 'function',\n    value: () => {}\n  },\n  onImageLoad: {\n    type: 'function',\n    value: () => {}\n  },\n  onImageLoadError: {\n    type: 'function',\n    compare: false,\n    value: (requestId, error) => console.error(error, requestId)\n  }\n};\nexport class WMSLayer extends CompositeLayer {\n  constructor() {\n    super(...arguments);\n    _defineProperty(this, \"state\", void 0);\n  }\n  get isLoaded() {\n    return Boolean(this.state) && this.state.loadCounter === 0 && super.isLoaded;\n  }\n  shouldUpdateState() {\n    return true;\n  }\n  initializeState() {\n    this.state._nextRequestId = 0;\n    this.state.lastRequestId = -1;\n    this.state.loadCounter = 0;\n  }\n  updateState(_ref) {\n    let {\n      changeFlags,\n      props,\n      oldProps\n    } = _ref;\n    const {\n      viewport\n    } = this.context;\n    if (changeFlags.dataChanged || props.serviceType !== oldProps.serviceType) {\n      this.state.imageSource = this._createImageSource(props);\n      this._loadMetadata();\n      this.debounce(() => this.loadImage(viewport, 'image source changed'), 0);\n    } else if (!deepEqual(props.layers, oldProps.layers, 1)) {\n      this.debounce(() => this.loadImage(viewport, 'layers changed'), 0);\n    } else if (changeFlags.viewportChanged) {\n      this.debounce(() => this.loadImage(viewport, 'viewport changed'));\n    }\n  }\n  finalizeState() {}\n  renderLayers() {\n    const {\n      bounds,\n      image,\n      lastRequestParameters\n    } = this.state;\n    return image && new BitmapLayer({\n      ...this.getSubLayerProps({\n        id: 'bitmap'\n      }),\n      _imageCoordinateSystem: lastRequestParameters.srs === 'EPSG:4326' ? COORDINATE_SYSTEM.LNGLAT : COORDINATE_SYSTEM.CARTESIAN,\n      bounds,\n      image\n    });\n  }\n  async getFeatureInfoText(x, y) {\n    const {\n      lastRequestParameters\n    } = this.state;\n    if (lastRequestParameters) {\n      var _this$state$imageSour, _this$state$imageSour2;\n      const featureInfo = await ((_this$state$imageSour = (_this$state$imageSour2 = this.state.imageSource).getFeatureInfoText) === null || _this$state$imageSour === void 0 ? void 0 : _this$state$imageSour.call(_this$state$imageSour2, {\n        ...lastRequestParameters,\n        query_layers: lastRequestParameters.layers,\n        x,\n        y,\n        info_format: 'application/vnd.ogc.gml'\n      }));\n      return featureInfo;\n    }\n    return '';\n  }\n  _createImageSource(props) {\n    if (props.data instanceof ImageSource) {\n      return props.data;\n    }\n    if (typeof props.data === 'string') {\n      return createImageSource({\n        url: props.data,\n        loadOptions: props.loadOptions,\n        type: props.serviceType\n      });\n    }\n    throw new Error('invalid image source in props.data');\n  }\n  async _loadMetadata() {\n    const {\n      imageSource\n    } = this.state;\n    try {\n      this.state.loadCounter++;\n      const metadata = await imageSource.getMetadata();\n      if (this.state.imageSource === imageSource) {\n        var _this$getCurrentLayer;\n        (_this$getCurrentLayer = this.getCurrentLayer()) === null || _this$getCurrentLayer === void 0 ? void 0 : _this$getCurrentLayer.props.onMetadataLoad(metadata);\n      }\n    } catch (error) {\n      var _this$getCurrentLayer2;\n      (_this$getCurrentLayer2 = this.getCurrentLayer()) === null || _this$getCurrentLayer2 === void 0 ? void 0 : _this$getCurrentLayer2.props.onMetadataLoadError(error);\n    } finally {\n      this.state.loadCounter--;\n    }\n  }\n  async loadImage(viewport, reason) {\n    const {\n      layers,\n      serviceType\n    } = this.props;\n    if (serviceType === 'wms' && layers.length === 0) {\n      return;\n    }\n    const bounds = viewport.getBounds();\n    const {\n      width,\n      height\n    } = viewport;\n    const requestId = this.getRequestId();\n    let {\n      srs\n    } = this.props;\n    if (srs === 'auto') {\n      srs = viewport.resolution ? 'EPSG:4326' : 'EPSG:3857';\n    }\n    const requestParams = {\n      width,\n      height,\n      bbox: bounds,\n      layers,\n      srs\n    };\n    if (srs === 'EPSG:3857') {\n      const [minX, minY] = WGS84ToPseudoMercator([bounds[0], bounds[1]]);\n      const [maxX, maxY] = WGS84ToPseudoMercator([bounds[2], bounds[3]]);\n      requestParams.bbox = [minX, minY, maxX, maxY];\n    }\n    try {\n      this.state.loadCounter++;\n      this.props.onImageLoadStart(requestId);\n      const image = await this.state.imageSource.getImage(requestParams);\n      if (this.state.lastRequestId < requestId) {\n        var _this$getCurrentLayer3;\n        (_this$getCurrentLayer3 = this.getCurrentLayer()) === null || _this$getCurrentLayer3 === void 0 ? void 0 : _this$getCurrentLayer3.props.onImageLoad(requestId);\n        this.setState({\n          image,\n          bounds,\n          lastRequestParameters: requestParams,\n          lastRequestId: requestId\n        });\n      }\n    } catch (error) {\n      var _this$getCurrentLayer4;\n      this.raiseError(error, 'Load image');\n      (_this$getCurrentLayer4 = this.getCurrentLayer()) === null || _this$getCurrentLayer4 === void 0 ? void 0 : _this$getCurrentLayer4.props.onImageLoadError(requestId, error);\n    } finally {\n      this.state.loadCounter--;\n    }\n  }\n  getRequestId() {\n    return this.state._nextRequestId++;\n  }\n  debounce(fn) {\n    let ms = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 500;\n    clearTimeout(this.state._timeoutId);\n    this.state._timeoutId = setTimeout(() => fn(), ms);\n  }\n}\n_defineProperty(WMSLayer, \"layerName\", 'WMSLayer');\n_defineProperty(WMSLayer, \"defaultProps\", defaultProps);","map":{"version":3,"names":["CompositeLayer","COORDINATE_SYSTEM","_deepEqual","deepEqual","BitmapLayer","ImageSource","createImageSource","WGS84ToPseudoMercator","defaultProps","id","data","serviceType","srs","layers","type","compare","value","onMetadataLoad","onMetadataLoadError","console","error","onImageLoadStart","onImageLoad","onImageLoadError","requestId","WMSLayer","constructor","arguments","_defineProperty","isLoaded","Boolean","state","loadCounter","shouldUpdateState","initializeState","_nextRequestId","lastRequestId","updateState","_ref","changeFlags","props","oldProps","viewport","context","dataChanged","imageSource","_createImageSource","_loadMetadata","debounce","loadImage","viewportChanged","finalizeState","renderLayers","bounds","image","lastRequestParameters","getSubLayerProps","_imageCoordinateSystem","LNGLAT","CARTESIAN","getFeatureInfoText","x","y","_this$state$imageSour","_this$state$imageSour2","featureInfo","call","query_layers","info_format","url","loadOptions","Error","metadata","getMetadata","_this$getCurrentLayer","getCurrentLayer","_this$getCurrentLayer2","reason","length","getBounds","width","height","getRequestId","resolution","requestParams","bbox","minX","minY","maxX","maxY","getImage","_this$getCurrentLayer3","setState","_this$getCurrentLayer4","raiseError","fn","ms","undefined","clearTimeout","_timeoutId","setTimeout"],"sources":["../../../src/wms-layer/wms-layer.ts"],"sourcesContent":["// deck.gl, MIT license\n// Attributions:\n// Copyright 2022 Foursquare Labs, Inc.\n\n/* eslint-disable camelcase */ // Some WMS parameters are not in camel case\n/* global setTimeout, clearTimeout */\n\nimport {\n  Layer,\n  CompositeLayer,\n  CompositeLayerProps,\n  UpdateParameters,\n  DefaultProps,\n  Viewport,\n  COORDINATE_SYSTEM,\n  _deepEqual as deepEqual\n} from '@deck.gl/core';\nimport {BitmapLayer} from '@deck.gl/layers';\nimport type {ImageSourceMetadata, ImageType, ImageServiceType} from '@loaders.gl/wms';\nimport {ImageSource, createImageSource} from '@loaders.gl/wms';\nimport {WGS84ToPseudoMercator} from './utils';\n\n/** All props supported by the TileLayer */\nexport type WMSLayerProps = CompositeLayerProps & _WMSLayerProps;\n\n/** Props added by the TileLayer */\ntype _WMSLayerProps = {\n  data: string | ImageSource;\n  serviceType?: ImageServiceType | 'auto';\n  layers?: string[];\n  srs?: 'EPSG:4326' | 'EPSG:3857' | 'auto';\n  onMetadataLoad?: (metadata: ImageSourceMetadata) => void;\n  onMetadataLoadError?: (error: Error) => void;\n  onImageLoadStart?: (requestId: unknown) => void;\n  onImageLoad?: (requestId: unknown) => void;\n  onImageLoadError?: (requestId: unknown, error: Error) => void;\n};\n\nconst defaultProps: DefaultProps<WMSLayerProps> = {\n  id: 'imagery-layer',\n  data: '',\n  serviceType: 'auto',\n  srs: 'auto',\n  layers: {type: 'array', compare: true, value: []},\n  onMetadataLoad: {type: 'function', value: () => {}},\n  // eslint-disable-next-line\n  onMetadataLoadError: {type: 'function', value: console.error},\n  onImageLoadStart: {type: 'function', value: () => {}},\n  onImageLoad: {type: 'function', value: () => {}},\n  onImageLoadError: {\n    type: 'function',\n    compare: false,\n    // eslint-disable-next-line\n    value: (requestId: unknown, error: Error) => console.error(error, requestId)\n  }\n};\n\n/**\n * The layer is used in Hex Tile layer in order to properly discard invisible elements during animation\n */\nexport class WMSLayer<ExtraPropsT extends {} = {}> extends CompositeLayer<\n  ExtraPropsT & Required<_WMSLayerProps>\n> {\n  static layerName = 'WMSLayer';\n  static defaultProps: DefaultProps = defaultProps;\n\n  state!: {\n    imageSource: ImageSource;\n    image: ImageType;\n    bounds: [number, number, number, number];\n    lastRequestParameters: {\n      bbox: [number, number, number, number];\n      layers: string[];\n      srs: 'EPSG:4326' | 'EPSG:3857';\n      width: number;\n      height: number;\n    };\n    lastRequestId: number;\n    _nextRequestId: number;\n    /** TODO: Change any => setTimeout return type. Different between Node and browser... */\n    _timeoutId: any;\n    loadCounter: number;\n  };\n\n  /** Returns true if all async resources are loaded */\n  get isLoaded(): boolean {\n    // Track the explicit loading done by this layer\n    return Boolean(this.state) && this.state.loadCounter === 0 && super.isLoaded;\n  }\n\n  /** Lets deck.gl know that we want viewport change events */\n  override shouldUpdateState(): boolean {\n    return true;\n  }\n\n  override initializeState(): void {\n    // intentionally empty, initialization is done in updateState\n    this.state._nextRequestId = 0;\n    this.state.lastRequestId = -1;\n    this.state.loadCounter = 0;\n  }\n\n  override updateState({changeFlags, props, oldProps}: UpdateParameters<this>): void {\n    const {viewport} = this.context;\n\n    // Check if data source has changed\n    if (changeFlags.dataChanged || props.serviceType !== oldProps.serviceType) {\n      this.state.imageSource = this._createImageSource(props);\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      this._loadMetadata();\n      this.debounce(() => this.loadImage(viewport, 'image source changed'), 0);\n    } else if (!deepEqual(props.layers, oldProps.layers, 1)) {\n      this.debounce(() => this.loadImage(viewport, 'layers changed'), 0);\n    } else if (changeFlags.viewportChanged) {\n      this.debounce(() => this.loadImage(viewport, 'viewport changed'));\n    }\n  }\n\n  override finalizeState(): void {\n    // TODO - we could cancel outstanding requests\n  }\n\n  override renderLayers(): Layer {\n    // TODO - which bitmap layer is rendered should depend on the current viewport\n    // Currently Studio only uses one viewport\n    const {bounds, image, lastRequestParameters} = this.state;\n\n    return (\n      image &&\n      new BitmapLayer({\n        ...this.getSubLayerProps({id: 'bitmap'}),\n        _imageCoordinateSystem:\n          lastRequestParameters.srs === 'EPSG:4326'\n            ? COORDINATE_SYSTEM.LNGLAT\n            : COORDINATE_SYSTEM.CARTESIAN,\n        bounds,\n        image\n      })\n    );\n  }\n\n  async getFeatureInfoText(x: number, y: number): Promise<string | null> {\n    const {lastRequestParameters} = this.state;\n    if (lastRequestParameters) {\n      // @ts-expect-error Undocumented method\n      const featureInfo = await this.state.imageSource.getFeatureInfoText?.({\n        ...lastRequestParameters,\n        query_layers: lastRequestParameters.layers,\n        x,\n        y,\n        info_format: 'application/vnd.ogc.gml'\n      });\n      return featureInfo;\n    }\n    return '';\n  }\n\n  _createImageSource(props: WMSLayerProps): ImageSource {\n    if (props.data instanceof ImageSource) {\n      return props.data;\n    }\n\n    if (typeof props.data === 'string') {\n      return createImageSource({\n        url: props.data,\n        loadOptions: props.loadOptions,\n        type: props.serviceType\n      });\n    }\n\n    throw new Error('invalid image source in props.data');\n  }\n\n  /** Run a getMetadata on the image service */\n  async _loadMetadata(): Promise<void> {\n    const {imageSource} = this.state;\n    try {\n      this.state.loadCounter++;\n      const metadata = await imageSource.getMetadata();\n\n      // If a request takes a long time, it may no longer be expected\n      if (this.state.imageSource === imageSource) {\n        this.getCurrentLayer()?.props.onMetadataLoad(metadata);\n      }\n    } catch (error) {\n      this.getCurrentLayer()?.props.onMetadataLoadError(error as Error);\n    } finally {\n      this.state.loadCounter--;\n    }\n  }\n\n  /** Load an image */\n  async loadImage(viewport: Viewport, reason: string): Promise<void> {\n    const {layers, serviceType} = this.props;\n\n    // TODO - move to ImageSource?\n    if (serviceType === 'wms' && layers.length === 0) {\n      return;\n    }\n\n    const bounds = viewport.getBounds();\n    const {width, height} = viewport;\n    const requestId = this.getRequestId();\n    let {srs} = this.props;\n    if (srs === 'auto') {\n      // BitmapLayer only supports LNGLAT or CARTESIAN (Web-Mercator)\n      srs = viewport.resolution ? 'EPSG:4326' : 'EPSG:3857';\n    }\n    const requestParams = {\n      width,\n      height,\n      bbox: bounds,\n      layers,\n      srs\n    };\n    if (srs === 'EPSG:3857') {\n      const [minX, minY] = WGS84ToPseudoMercator([bounds[0], bounds[1]]);\n      const [maxX, maxY] = WGS84ToPseudoMercator([bounds[2], bounds[3]]);\n      requestParams.bbox = [minX, minY, maxX, maxY];\n    }\n\n    try {\n      this.state.loadCounter++;\n      this.props.onImageLoadStart(requestId);\n\n      const image = await this.state.imageSource.getImage(requestParams);\n\n      // If a request takes a long time, later requests may have already loaded.\n      if (this.state.lastRequestId < requestId) {\n        this.getCurrentLayer()?.props.onImageLoad(requestId);\n        // Not type safe...\n        this.setState({\n          image,\n          bounds,\n          lastRequestParameters: requestParams,\n          lastRequestId: requestId\n        });\n      }\n    } catch (error) {\n      this.raiseError(error as Error, 'Load image');\n      this.getCurrentLayer()?.props.onImageLoadError(requestId, error as Error);\n    } finally {\n      this.state.loadCounter--;\n    }\n  }\n\n  // HELPERS\n\n  /** Global counter for issuing unique request ids */\n  private getRequestId(): number {\n    return this.state._nextRequestId++;\n  }\n\n  /** Runs an action in the future, cancels it if the new action is issued before it executes */\n  private debounce(fn: Function, ms = 500): void {\n    clearTimeout(this.state._timeoutId);\n    this.state._timeoutId = setTimeout(() => fn(), ms);\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}