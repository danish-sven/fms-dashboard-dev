{"ast":null,"code":"import { feature, isObject, lineString, point } from '@turf/helpers';\n\n/**\n * Callback for coordEach\n *\n * @callback coordEachCallback\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()\n *\n * @name coordEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction coordEach(geojson, callback, excludeWrapCoord) {\n  // Handles null Geometry -- Skips this GeoJSON\n  if (geojson === null) return;\n  var j,\n    k,\n    l,\n    geometry,\n    stopG,\n    coords,\n    geometryMaybeCollection,\n    wrapShrink = 0,\n    coordIndex = 0,\n    isGeometryCollection,\n    type = geojson.type,\n    isFeatureCollection = type === 'FeatureCollection',\n    isFeature = type === 'Feature',\n    stop = isFeatureCollection ? geojson.features.length : 1;\n\n  // This logic may look a little weird. The reason why it is that way\n  // is because it's trying to be fast. GeoJSON supports multiple kinds\n  // of objects at its root: FeatureCollection, Features, Geometries.\n  // This function has the responsibility of handling all of them, and that\n  // means that some of the `for` loops you see below actually just don't apply\n  // to certain inputs. For instance, if you give this just a\n  // Point geometry, then both loops are short-circuited and all we do\n  // is gradually rename the input until it's called 'geometry'.\n  //\n  // This also aims to allocate as few resources as possible: just a\n  // few numbers and booleans, rather than any temporary arrays as would\n  // be required with the normalization approach.\n  for (var featureIndex = 0; featureIndex < stop; featureIndex++) {\n    geometryMaybeCollection = isFeatureCollection ? geojson.features[featureIndex].geometry : isFeature ? geojson.geometry : geojson;\n    isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n    stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n    for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {\n      var multiFeatureIndex = 0;\n      var geometryIndex = 0;\n      geometry = isGeometryCollection ? geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;\n\n      // Handles null Geometry -- Skips this geometry\n      if (geometry === null) continue;\n      coords = geometry.coordinates;\n      var geomType = geometry.type;\n      wrapShrink = excludeWrapCoord && (geomType === 'Polygon' || geomType === 'MultiPolygon') ? 1 : 0;\n      switch (geomType) {\n        case null:\n          break;\n        case 'Point':\n          if (callback(coords, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n          coordIndex++;\n          multiFeatureIndex++;\n          break;\n        case 'LineString':\n        case 'MultiPoint':\n          for (j = 0; j < coords.length; j++) {\n            if (callback(coords[j], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n            coordIndex++;\n            if (geomType === 'MultiPoint') multiFeatureIndex++;\n          }\n          if (geomType === 'LineString') multiFeatureIndex++;\n          break;\n        case 'Polygon':\n        case 'MultiLineString':\n          for (j = 0; j < coords.length; j++) {\n            for (k = 0; k < coords[j].length - wrapShrink; k++) {\n              if (callback(coords[j][k], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n              coordIndex++;\n            }\n            if (geomType === 'MultiLineString') multiFeatureIndex++;\n            if (geomType === 'Polygon') geometryIndex++;\n          }\n          if (geomType === 'Polygon') multiFeatureIndex++;\n          break;\n        case 'MultiPolygon':\n          for (j = 0; j < coords.length; j++) {\n            if (geomType === 'MultiPolygon') geometryIndex = 0;\n            for (k = 0; k < coords[j].length; k++) {\n              for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                if (callback(coords[j][k][l], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                coordIndex++;\n              }\n              geometryIndex++;\n            }\n            multiFeatureIndex++;\n          }\n          break;\n        case 'GeometryCollection':\n          for (j = 0; j < geometry.geometries.length; j++) if (coordEach(geometry.geometries[j], callback, excludeWrapCoord) === false) return false;\n          break;\n        default:\n          throw new Error('Unknown Geometry Type');\n      }\n    }\n  }\n}\n\n/**\n * Callback for coordReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback coordReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Reduce coordinates in any GeoJSON object, similar to Array.reduce()\n *\n * @name coordReduce\n * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentCoord;\n * });\n */\nfunction coordReduce(geojson, callback, initialValue, excludeWrapCoord) {\n  var previousValue = initialValue;\n  coordEach(geojson, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n    if (coordIndex === 0 && initialValue === undefined) previousValue = currentCoord;else previousValue = callback(previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex);\n  }, excludeWrapCoord);\n  return previousValue;\n}\n\n/**\n * Callback for propEach\n *\n * @callback propEachCallback\n * @param {Object} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over properties in any GeoJSON object, similar to Array.forEach()\n *\n * @name propEach\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentProperties, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propEach(features, function (currentProperties, featureIndex) {\n *   //=currentProperties\n *   //=featureIndex\n * });\n */\nfunction propEach(geojson, callback) {\n  var i;\n  switch (geojson.type) {\n    case 'FeatureCollection':\n      for (i = 0; i < geojson.features.length; i++) {\n        if (callback(geojson.features[i].properties, i) === false) break;\n      }\n      break;\n    case 'Feature':\n      callback(geojson.properties, 0);\n      break;\n  }\n}\n\n/**\n * Callback for propReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback propReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {*} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce properties in any GeoJSON object into a single value,\n * similar to how Array.reduce works. However, in this case we lazily run\n * the reduction, so an array of all properties is unnecessary.\n *\n * @name propReduce\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {\n *   //=previousValue\n *   //=currentProperties\n *   //=featureIndex\n *   return currentProperties\n * });\n */\nfunction propReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  propEach(geojson, function (currentProperties, featureIndex) {\n    if (featureIndex === 0 && initialValue === undefined) previousValue = currentProperties;else previousValue = callback(previousValue, currentProperties, featureIndex);\n  });\n  return previousValue;\n}\n\n/**\n * Callback for featureEach\n *\n * @callback featureEachCallback\n * @param {Feature<any>} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name featureEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.featureEach(features, function (currentFeature, featureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n * });\n */\nfunction featureEach(geojson, callback) {\n  if (geojson.type === 'Feature') {\n    callback(geojson, 0);\n  } else if (geojson.type === 'FeatureCollection') {\n    for (var i = 0; i < geojson.features.length; i++) {\n      if (callback(geojson.features[i], i) === false) break;\n    }\n  }\n}\n\n/**\n * Callback for featureReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback featureReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name featureReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   return currentFeature\n * });\n */\nfunction featureReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  featureEach(geojson, function (currentFeature, featureIndex) {\n    if (featureIndex === 0 && initialValue === undefined) previousValue = currentFeature;else previousValue = callback(previousValue, currentFeature, featureIndex);\n  });\n  return previousValue;\n}\n\n/**\n * Get all coordinates from any GeoJSON object.\n *\n * @name coordAll\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @returns {Array<Array<number>>} coordinate position array\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * var coords = turf.coordAll(features);\n * //= [[26, 37], [36, 53]]\n */\nfunction coordAll(geojson) {\n  var coords = [];\n  coordEach(geojson, function (coord) {\n    coords.push(coord);\n  });\n  return coords;\n}\n\n/**\n * Callback for geomEach\n *\n * @callback geomEachCallback\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()\n *\n * @name geomEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomEach(features, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n * });\n */\nfunction geomEach(geojson, callback) {\n  var i,\n    j,\n    g,\n    geometry,\n    stopG,\n    geometryMaybeCollection,\n    isGeometryCollection,\n    featureProperties,\n    featureBBox,\n    featureId,\n    featureIndex = 0,\n    isFeatureCollection = geojson.type === 'FeatureCollection',\n    isFeature = geojson.type === 'Feature',\n    stop = isFeatureCollection ? geojson.features.length : 1;\n\n  // This logic may look a little weird. The reason why it is that way\n  // is because it's trying to be fast. GeoJSON supports multiple kinds\n  // of objects at its root: FeatureCollection, Features, Geometries.\n  // This function has the responsibility of handling all of them, and that\n  // means that some of the `for` loops you see below actually just don't apply\n  // to certain inputs. For instance, if you give this just a\n  // Point geometry, then both loops are short-circuited and all we do\n  // is gradually rename the input until it's called 'geometry'.\n  //\n  // This also aims to allocate as few resources as possible: just a\n  // few numbers and booleans, rather than any temporary arrays as would\n  // be required with the normalization approach.\n  for (i = 0; i < stop; i++) {\n    geometryMaybeCollection = isFeatureCollection ? geojson.features[i].geometry : isFeature ? geojson.geometry : geojson;\n    featureProperties = isFeatureCollection ? geojson.features[i].properties : isFeature ? geojson.properties : {};\n    featureBBox = isFeatureCollection ? geojson.features[i].bbox : isFeature ? geojson.bbox : undefined;\n    featureId = isFeatureCollection ? geojson.features[i].id : isFeature ? geojson.id : undefined;\n    isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n    stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n    for (g = 0; g < stopG; g++) {\n      geometry = isGeometryCollection ? geometryMaybeCollection.geometries[g] : geometryMaybeCollection;\n\n      // Handle null Geometry\n      if (geometry === null) {\n        if (callback(null, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n        continue;\n      }\n      switch (geometry.type) {\n        case 'Point':\n        case 'LineString':\n        case 'MultiPoint':\n        case 'Polygon':\n        case 'MultiLineString':\n        case 'MultiPolygon':\n          {\n            if (callback(geometry, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n            break;\n          }\n        case 'GeometryCollection':\n          {\n            for (j = 0; j < geometry.geometries.length; j++) {\n              if (callback(geometry.geometries[j], featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n            }\n            break;\n          }\n        default:\n          throw new Error('Unknown Geometry Type');\n      }\n    }\n    // Only increase `featureIndex` per each feature\n    featureIndex++;\n  }\n}\n\n/**\n * Callback for geomReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback geomReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Reduce geometry in any GeoJSON object, similar to Array.reduce().\n *\n * @name geomReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=previousValue\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n *   return currentGeometry\n * });\n */\nfunction geomReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  geomEach(geojson, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n    if (featureIndex === 0 && initialValue === undefined) previousValue = currentGeometry;else previousValue = callback(previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId);\n  });\n  return previousValue;\n}\n\n/**\n * Callback for flattenEach\n *\n * @callback flattenEachCallback\n * @param {Feature} currentFeature The current flattened feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Iterate over flattened features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name flattenEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex, multiFeatureIndex)\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenEach(features, function (currentFeature, featureIndex, multiFeatureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n * });\n */\nfunction flattenEach(geojson, callback) {\n  geomEach(geojson, function (geometry, featureIndex, properties, bbox, id) {\n    // Callback for single geometry\n    var type = geometry === null ? null : geometry.type;\n    switch (type) {\n      case null:\n      case 'Point':\n      case 'LineString':\n      case 'Polygon':\n        if (callback(feature(geometry, properties, {\n          bbox: bbox,\n          id: id\n        }), featureIndex, 0) === false) return false;\n        return;\n    }\n    var geomType;\n\n    // Callback for multi-geometry\n    switch (type) {\n      case 'MultiPoint':\n        geomType = 'Point';\n        break;\n      case 'MultiLineString':\n        geomType = 'LineString';\n        break;\n      case 'MultiPolygon':\n        geomType = 'Polygon';\n        break;\n    }\n    for (var multiFeatureIndex = 0; multiFeatureIndex < geometry.coordinates.length; multiFeatureIndex++) {\n      var coordinate = geometry.coordinates[multiFeatureIndex];\n      var geom = {\n        type: geomType,\n        coordinates: coordinate\n      };\n      if (callback(feature(geom, properties), featureIndex, multiFeatureIndex) === false) return false;\n    }\n  });\n}\n\n/**\n * Callback for flattenReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback flattenReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Reduce flattened features in any GeoJSON object, similar to Array.reduce().\n *\n * @name flattenReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, multiFeatureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, multiFeatureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   return currentFeature\n * });\n */\nfunction flattenReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  flattenEach(geojson, function (currentFeature, featureIndex, multiFeatureIndex) {\n    if (featureIndex === 0 && multiFeatureIndex === 0 && initialValue === undefined) previousValue = currentFeature;else previousValue = callback(previousValue, currentFeature, featureIndex, multiFeatureIndex);\n  });\n  return previousValue;\n}\n\n/**\n * Callback for segmentEach\n *\n * @callback segmentEachCallback\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n * @returns {void}\n */\n\n/**\n * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex)\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentEach(polygon, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //=currentSegment\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   //=segmentIndex\n * });\n *\n * // Calculate the total number of segments\n * var total = 0;\n * turf.segmentEach(polygon, function () {\n *     total++;\n * });\n */\nfunction segmentEach(geojson, callback) {\n  flattenEach(geojson, function (feature$$1, featureIndex, multiFeatureIndex) {\n    var segmentIndex = 0;\n\n    // Exclude null Geometries\n    if (!feature$$1.geometry) return;\n    // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n    var type = feature$$1.geometry.type;\n    if (type === 'Point' || type === 'MultiPoint') return;\n\n    // Generate 2-vertex line segments\n    var previousCoords;\n    if (coordEach(feature$$1, function (currentCoord, coordIndex, featureIndexCoord, mutliPartIndexCoord, geometryIndex) {\n      // Simulating a meta.coordReduce() since `reduce` operations cannot be stopped by returning `false`\n      if (previousCoords === undefined) {\n        previousCoords = currentCoord;\n        return;\n      }\n      var currentSegment = lineString([previousCoords, currentCoord], feature$$1.properties);\n      if (callback(currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) === false) return false;\n      segmentIndex++;\n      previousCoords = currentCoord;\n    }) === false) return false;\n  });\n}\n\n/**\n * Callback for segmentReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback segmentReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n */\n\n/**\n * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //= previousSegment\n *   //= currentSegment\n *   //= featureIndex\n *   //= multiFeatureIndex\n *   //= geometryIndex\n *   //= segmentInex\n *   return currentSegment\n * });\n *\n * // Calculate the total number of segments\n * var initialValue = 0\n * var total = turf.segmentReduce(polygon, function (previousValue) {\n *     previousValue++;\n *     return previousValue;\n * }, initialValue);\n */\nfunction segmentReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  var started = false;\n  segmentEach(geojson, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n    if (started === false && initialValue === undefined) previousValue = currentSegment;else previousValue = callback(previousValue, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex);\n    started = true;\n  });\n  return previousValue;\n}\n\n/**\n * Callback for lineEach\n *\n * @callback lineEachCallback\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,\n * similar to Array.forEach.\n *\n * @name lineEach\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @example\n * var multiLine = turf.multiLineString([\n *   [[26, 37], [35, 45]],\n *   [[36, 53], [38, 50], [41, 55]]\n * ]);\n *\n * turf.lineEach(multiLine, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction lineEach(geojson, callback) {\n  // validation\n  if (!geojson) throw new Error('geojson is required');\n  flattenEach(geojson, function (feature$$1, featureIndex, multiFeatureIndex) {\n    if (feature$$1.geometry === null) return;\n    var type = feature$$1.geometry.type;\n    var coords = feature$$1.geometry.coordinates;\n    switch (type) {\n      case 'LineString':\n        if (callback(feature$$1, featureIndex, multiFeatureIndex, 0, 0) === false) return false;\n        break;\n      case 'Polygon':\n        for (var geometryIndex = 0; geometryIndex < coords.length; geometryIndex++) {\n          if (callback(lineString(coords[geometryIndex], feature$$1.properties), featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n        }\n        break;\n    }\n  });\n}\n\n/**\n * Callback for lineReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback lineReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name lineReduce\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var multiPoly = turf.multiPolygon([\n *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),\n *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])\n * ]);\n *\n * turf.lineReduce(multiPoly, function (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentLine\n * });\n */\nfunction lineReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  lineEach(geojson, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n    if (featureIndex === 0 && initialValue === undefined) previousValue = currentLine;else previousValue = callback(previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex);\n  });\n  return previousValue;\n}\n\n/**\n * Finds a particular 2-vertex LineString Segment from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n * Point & MultiPoint will always return null.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.segmentIndex=0] Segment Index\n * @param {Object} [options.properties={}] Translate Properties to output LineString\n * @param {BBox} [options.bbox={}] Translate BBox to output LineString\n * @param {number|string} [options.id={}] Translate Id to output LineString\n * @returns {Feature<LineString>} 2-vertex GeoJSON Feature LineString\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findSegment(multiLine);\n * // => Feature<LineString<[[10, 10], [50, 30]]>>\n *\n * // First Segment of 2nd Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: 1});\n * // => Feature<LineString<[[-10, -10], [-50, -30]]>>\n *\n * // Last Segment of Last Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: -1, segmentIndex: -1});\n * // => Feature<LineString<[[-50, -30], [-30, -40]]>>\n */\nfunction findSegment(geojson, options) {\n  // Optional Parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error('options is invalid');\n  var featureIndex = options.featureIndex || 0;\n  var multiFeatureIndex = options.multiFeatureIndex || 0;\n  var geometryIndex = options.geometryIndex || 0;\n  var segmentIndex = options.segmentIndex || 0;\n\n  // Find FeatureIndex\n  var properties = options.properties;\n  var geometry;\n  switch (geojson.type) {\n    case 'FeatureCollection':\n      if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;\n      properties = properties || geojson.features[featureIndex].properties;\n      geometry = geojson.features[featureIndex].geometry;\n      break;\n    case 'Feature':\n      properties = properties || geojson.properties;\n      geometry = geojson.geometry;\n      break;\n    case 'Point':\n    case 'MultiPoint':\n      return null;\n    case 'LineString':\n    case 'Polygon':\n    case 'MultiLineString':\n    case 'MultiPolygon':\n      geometry = geojson;\n      break;\n    default:\n      throw new Error('geojson is invalid');\n  }\n\n  // Find SegmentIndex\n  if (geometry === null) return null;\n  var coords = geometry.coordinates;\n  switch (geometry.type) {\n    case 'Point':\n    case 'MultiPoint':\n      return null;\n    case 'LineString':\n      if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;\n      return lineString([coords[segmentIndex], coords[segmentIndex + 1]], properties, options);\n    case 'Polygon':\n      if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n      if (segmentIndex < 0) segmentIndex = coords[geometryIndex].length + segmentIndex - 1;\n      return lineString([coords[geometryIndex][segmentIndex], coords[geometryIndex][segmentIndex + 1]], properties, options);\n    case 'MultiLineString':\n      if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;\n      return lineString([coords[multiFeatureIndex][segmentIndex], coords[multiFeatureIndex][segmentIndex + 1]], properties, options);\n    case 'MultiPolygon':\n      if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n      if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;\n      return lineString([coords[multiFeatureIndex][geometryIndex][segmentIndex], coords[multiFeatureIndex][geometryIndex][segmentIndex + 1]], properties, options);\n  }\n  throw new Error('geojson is invalid');\n}\n\n/**\n * Finds a particular Point from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.coordIndex=0] Coord Index\n * @param {Object} [options.properties={}] Translate Properties to output Point\n * @param {BBox} [options.bbox={}] Translate BBox to output Point\n * @param {number|string} [options.id={}] Translate Id to output Point\n * @returns {Feature<Point>} 2-vertex GeoJSON Feature Point\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findPoint(multiLine);\n * // => Feature<Point<[10, 10]>>\n *\n * // First Segment of the 2nd Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: 1});\n * // => Feature<Point<[-10, -10]>>\n *\n * // Last Segment of last Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: -1, coordIndex: -1});\n * // => Feature<Point<[-30, -40]>>\n */\nfunction findPoint(geojson, options) {\n  // Optional Parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error('options is invalid');\n  var featureIndex = options.featureIndex || 0;\n  var multiFeatureIndex = options.multiFeatureIndex || 0;\n  var geometryIndex = options.geometryIndex || 0;\n  var coordIndex = options.coordIndex || 0;\n\n  // Find FeatureIndex\n  var properties = options.properties;\n  var geometry;\n  switch (geojson.type) {\n    case 'FeatureCollection':\n      if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;\n      properties = properties || geojson.features[featureIndex].properties;\n      geometry = geojson.features[featureIndex].geometry;\n      break;\n    case 'Feature':\n      properties = properties || geojson.properties;\n      geometry = geojson.geometry;\n      break;\n    case 'Point':\n    case 'MultiPoint':\n      return null;\n    case 'LineString':\n    case 'Polygon':\n    case 'MultiLineString':\n    case 'MultiPolygon':\n      geometry = geojson;\n      break;\n    default:\n      throw new Error('geojson is invalid');\n  }\n\n  // Find Coord Index\n  if (geometry === null) return null;\n  var coords = geometry.coordinates;\n  switch (geometry.type) {\n    case 'Point':\n      return point(coords, properties, options);\n    case 'MultiPoint':\n      if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n      return point(coords[multiFeatureIndex], properties, options);\n    case 'LineString':\n      if (coordIndex < 0) coordIndex = coords.length + coordIndex;\n      return point(coords[coordIndex], properties, options);\n    case 'Polygon':\n      if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n      if (coordIndex < 0) coordIndex = coords[geometryIndex].length + coordIndex;\n      return point(coords[geometryIndex][coordIndex], properties, options);\n    case 'MultiLineString':\n      if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (coordIndex < 0) coordIndex = coords[multiFeatureIndex].length + coordIndex;\n      return point(coords[multiFeatureIndex][coordIndex], properties, options);\n    case 'MultiPolygon':\n      if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n      if (coordIndex < 0) coordIndex = coords[multiFeatureIndex][geometryIndex].length - coordIndex;\n      return point(coords[multiFeatureIndex][geometryIndex][coordIndex], properties, options);\n  }\n  throw new Error('geojson is invalid');\n}\nexport { coordEach, coordReduce, propEach, propReduce, featureEach, featureReduce, coordAll, geomEach, geomReduce, flattenEach, flattenReduce, segmentEach, segmentReduce, lineEach, lineReduce, findSegment, findPoint };","map":{"version":3,"names":["feature","isObject","lineString","point","coordEach","geojson","callback","excludeWrapCoord","j","k","l","geometry","stopG","coords","geometryMaybeCollection","wrapShrink","coordIndex","isGeometryCollection","type","isFeatureCollection","isFeature","stop","features","length","featureIndex","geometries","geomIndex","multiFeatureIndex","geometryIndex","coordinates","geomType","Error","coordReduce","initialValue","previousValue","currentCoord","undefined","propEach","i","properties","propReduce","currentProperties","featureEach","featureReduce","currentFeature","coordAll","coord","push","geomEach","g","featureProperties","featureBBox","featureId","bbox","id","geomReduce","currentGeometry","flattenEach","coordinate","geom","flattenReduce","segmentEach","feature$$1","segmentIndex","previousCoords","featureIndexCoord","mutliPartIndexCoord","currentSegment","segmentReduce","started","lineEach","lineReduce","currentLine","findSegment","options","findPoint"],"sources":["/Users/stefanhall/Documents/Employment/Zoomo/Git/repos/fms-dashboard-dev/node_modules/@turf/meta/main.es.js"],"sourcesContent":["import { feature, isObject, lineString, point } from '@turf/helpers';\n\n/**\n * Callback for coordEach\n *\n * @callback coordEachCallback\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()\n *\n * @name coordEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction coordEach(geojson, callback, excludeWrapCoord) {\n    // Handles null Geometry -- Skips this GeoJSON\n    if (geojson === null) return;\n    var j, k, l, geometry, stopG, coords,\n        geometryMaybeCollection,\n        wrapShrink = 0,\n        coordIndex = 0,\n        isGeometryCollection,\n        type = geojson.type,\n        isFeatureCollection = type === 'FeatureCollection',\n        isFeature = type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (var featureIndex = 0; featureIndex < stop; featureIndex++) {\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[featureIndex].geometry :\n            (isFeature ? geojson.geometry : geojson));\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {\n            var multiFeatureIndex = 0;\n            var geometryIndex = 0;\n            geometry = isGeometryCollection ?\n                geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;\n\n            // Handles null Geometry -- Skips this geometry\n            if (geometry === null) continue;\n            coords = geometry.coordinates;\n            var geomType = geometry.type;\n\n            wrapShrink = (excludeWrapCoord && (geomType === 'Polygon' || geomType === 'MultiPolygon')) ? 1 : 0;\n\n            switch (geomType) {\n            case null:\n                break;\n            case 'Point':\n                if (callback(coords, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                coordIndex++;\n                multiFeatureIndex++;\n                break;\n            case 'LineString':\n            case 'MultiPoint':\n                for (j = 0; j < coords.length; j++) {\n                    if (callback(coords[j], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                    coordIndex++;\n                    if (geomType === 'MultiPoint') multiFeatureIndex++;\n                }\n                if (geomType === 'LineString') multiFeatureIndex++;\n                break;\n            case 'Polygon':\n            case 'MultiLineString':\n                for (j = 0; j < coords.length; j++) {\n                    for (k = 0; k < coords[j].length - wrapShrink; k++) {\n                        if (callback(coords[j][k], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                        coordIndex++;\n                    }\n                    if (geomType === 'MultiLineString') multiFeatureIndex++;\n                    if (geomType === 'Polygon') geometryIndex++;\n                }\n                if (geomType === 'Polygon') multiFeatureIndex++;\n                break;\n            case 'MultiPolygon':\n                for (j = 0; j < coords.length; j++) {\n                    if (geomType === 'MultiPolygon') geometryIndex = 0;\n                    for (k = 0; k < coords[j].length; k++) {\n                        for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                            if (callback(coords[j][k][l], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                            coordIndex++;\n                        }\n                        geometryIndex++;\n                    }\n                    multiFeatureIndex++;\n                }\n                break;\n            case 'GeometryCollection':\n                for (j = 0; j < geometry.geometries.length; j++)\n                    if (coordEach(geometry.geometries[j], callback, excludeWrapCoord) === false) return false;\n                break;\n            default:\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n    }\n}\n\n/**\n * Callback for coordReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback coordReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Reduce coordinates in any GeoJSON object, similar to Array.reduce()\n *\n * @name coordReduce\n * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentCoord;\n * });\n */\nfunction coordReduce(geojson, callback, initialValue, excludeWrapCoord) {\n    var previousValue = initialValue;\n    coordEach(geojson, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n        if (coordIndex === 0 && initialValue === undefined) previousValue = currentCoord;\n        else previousValue = callback(previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex);\n    }, excludeWrapCoord);\n    return previousValue;\n}\n\n/**\n * Callback for propEach\n *\n * @callback propEachCallback\n * @param {Object} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over properties in any GeoJSON object, similar to Array.forEach()\n *\n * @name propEach\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentProperties, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propEach(features, function (currentProperties, featureIndex) {\n *   //=currentProperties\n *   //=featureIndex\n * });\n */\nfunction propEach(geojson, callback) {\n    var i;\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        for (i = 0; i < geojson.features.length; i++) {\n            if (callback(geojson.features[i].properties, i) === false) break;\n        }\n        break;\n    case 'Feature':\n        callback(geojson.properties, 0);\n        break;\n    }\n}\n\n\n/**\n * Callback for propReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback propReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {*} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce properties in any GeoJSON object into a single value,\n * similar to how Array.reduce works. However, in this case we lazily run\n * the reduction, so an array of all properties is unnecessary.\n *\n * @name propReduce\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {\n *   //=previousValue\n *   //=currentProperties\n *   //=featureIndex\n *   return currentProperties\n * });\n */\nfunction propReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    propEach(geojson, function (currentProperties, featureIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentProperties;\n        else previousValue = callback(previousValue, currentProperties, featureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for featureEach\n *\n * @callback featureEachCallback\n * @param {Feature<any>} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name featureEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.featureEach(features, function (currentFeature, featureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n * });\n */\nfunction featureEach(geojson, callback) {\n    if (geojson.type === 'Feature') {\n        callback(geojson, 0);\n    } else if (geojson.type === 'FeatureCollection') {\n        for (var i = 0; i < geojson.features.length; i++) {\n            if (callback(geojson.features[i], i) === false) break;\n        }\n    }\n}\n\n/**\n * Callback for featureReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback featureReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name featureReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   return currentFeature\n * });\n */\nfunction featureReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    featureEach(geojson, function (currentFeature, featureIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentFeature;\n        else previousValue = callback(previousValue, currentFeature, featureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Get all coordinates from any GeoJSON object.\n *\n * @name coordAll\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @returns {Array<Array<number>>} coordinate position array\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * var coords = turf.coordAll(features);\n * //= [[26, 37], [36, 53]]\n */\nfunction coordAll(geojson) {\n    var coords = [];\n    coordEach(geojson, function (coord) {\n        coords.push(coord);\n    });\n    return coords;\n}\n\n/**\n * Callback for geomEach\n *\n * @callback geomEachCallback\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()\n *\n * @name geomEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomEach(features, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n * });\n */\nfunction geomEach(geojson, callback) {\n    var i, j, g, geometry, stopG,\n        geometryMaybeCollection,\n        isGeometryCollection,\n        featureProperties,\n        featureBBox,\n        featureId,\n        featureIndex = 0,\n        isFeatureCollection = geojson.type === 'FeatureCollection',\n        isFeature = geojson.type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (i = 0; i < stop; i++) {\n\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[i].geometry :\n            (isFeature ? geojson.geometry : geojson));\n        featureProperties = (isFeatureCollection ? geojson.features[i].properties :\n            (isFeature ? geojson.properties : {}));\n        featureBBox = (isFeatureCollection ? geojson.features[i].bbox :\n            (isFeature ? geojson.bbox : undefined));\n        featureId = (isFeatureCollection ? geojson.features[i].id :\n            (isFeature ? geojson.id : undefined));\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (g = 0; g < stopG; g++) {\n            geometry = isGeometryCollection ?\n                geometryMaybeCollection.geometries[g] : geometryMaybeCollection;\n\n            // Handle null Geometry\n            if (geometry === null) {\n                if (callback(null, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                continue;\n            }\n            switch (geometry.type) {\n            case 'Point':\n            case 'LineString':\n            case 'MultiPoint':\n            case 'Polygon':\n            case 'MultiLineString':\n            case 'MultiPolygon': {\n                if (callback(geometry, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                break;\n            }\n            case 'GeometryCollection': {\n                for (j = 0; j < geometry.geometries.length; j++) {\n                    if (callback(geometry.geometries[j], featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                }\n                break;\n            }\n            default:\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n        // Only increase `featureIndex` per each feature\n        featureIndex++;\n    }\n}\n\n/**\n * Callback for geomReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback geomReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Reduce geometry in any GeoJSON object, similar to Array.reduce().\n *\n * @name geomReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=previousValue\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n *   return currentGeometry\n * });\n */\nfunction geomReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    geomEach(geojson, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentGeometry;\n        else previousValue = callback(previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for flattenEach\n *\n * @callback flattenEachCallback\n * @param {Feature} currentFeature The current flattened feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Iterate over flattened features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name flattenEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex, multiFeatureIndex)\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenEach(features, function (currentFeature, featureIndex, multiFeatureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n * });\n */\nfunction flattenEach(geojson, callback) {\n    geomEach(geojson, function (geometry, featureIndex, properties, bbox, id) {\n        // Callback for single geometry\n        var type = (geometry === null) ? null : geometry.type;\n        switch (type) {\n        case null:\n        case 'Point':\n        case 'LineString':\n        case 'Polygon':\n            if (callback(feature(geometry, properties, {bbox: bbox, id: id}), featureIndex, 0) === false) return false;\n            return;\n        }\n\n        var geomType;\n\n        // Callback for multi-geometry\n        switch (type) {\n        case 'MultiPoint':\n            geomType = 'Point';\n            break;\n        case 'MultiLineString':\n            geomType = 'LineString';\n            break;\n        case 'MultiPolygon':\n            geomType = 'Polygon';\n            break;\n        }\n\n        for (var multiFeatureIndex = 0; multiFeatureIndex < geometry.coordinates.length; multiFeatureIndex++) {\n            var coordinate = geometry.coordinates[multiFeatureIndex];\n            var geom = {\n                type: geomType,\n                coordinates: coordinate\n            };\n            if (callback(feature(geom, properties), featureIndex, multiFeatureIndex) === false) return false;\n        }\n    });\n}\n\n/**\n * Callback for flattenReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback flattenReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Reduce flattened features in any GeoJSON object, similar to Array.reduce().\n *\n * @name flattenReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, multiFeatureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, multiFeatureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   return currentFeature\n * });\n */\nfunction flattenReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    flattenEach(geojson, function (currentFeature, featureIndex, multiFeatureIndex) {\n        if (featureIndex === 0 && multiFeatureIndex === 0 && initialValue === undefined) previousValue = currentFeature;\n        else previousValue = callback(previousValue, currentFeature, featureIndex, multiFeatureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for segmentEach\n *\n * @callback segmentEachCallback\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n * @returns {void}\n */\n\n/**\n * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex)\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentEach(polygon, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //=currentSegment\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   //=segmentIndex\n * });\n *\n * // Calculate the total number of segments\n * var total = 0;\n * turf.segmentEach(polygon, function () {\n *     total++;\n * });\n */\nfunction segmentEach(geojson, callback) {\n    flattenEach(geojson, function (feature$$1, featureIndex, multiFeatureIndex) {\n        var segmentIndex = 0;\n\n        // Exclude null Geometries\n        if (!feature$$1.geometry) return;\n        // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n        var type = feature$$1.geometry.type;\n        if (type === 'Point' || type === 'MultiPoint') return;\n\n        // Generate 2-vertex line segments\n        var previousCoords;\n        if (coordEach(feature$$1, function (currentCoord, coordIndex, featureIndexCoord, mutliPartIndexCoord, geometryIndex) {\n            // Simulating a meta.coordReduce() since `reduce` operations cannot be stopped by returning `false`\n            if (previousCoords === undefined) {\n                previousCoords = currentCoord;\n                return;\n            }\n            var currentSegment = lineString([previousCoords, currentCoord], feature$$1.properties);\n            if (callback(currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) === false) return false;\n            segmentIndex++;\n            previousCoords = currentCoord;\n        }) === false) return false;\n    });\n}\n\n/**\n * Callback for segmentReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback segmentReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n */\n\n/**\n * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //= previousSegment\n *   //= currentSegment\n *   //= featureIndex\n *   //= multiFeatureIndex\n *   //= geometryIndex\n *   //= segmentInex\n *   return currentSegment\n * });\n *\n * // Calculate the total number of segments\n * var initialValue = 0\n * var total = turf.segmentReduce(polygon, function (previousValue) {\n *     previousValue++;\n *     return previousValue;\n * }, initialValue);\n */\nfunction segmentReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    var started = false;\n    segmentEach(geojson, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n        if (started === false && initialValue === undefined) previousValue = currentSegment;\n        else previousValue = callback(previousValue, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex);\n        started = true;\n    });\n    return previousValue;\n}\n\n/**\n * Callback for lineEach\n *\n * @callback lineEachCallback\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,\n * similar to Array.forEach.\n *\n * @name lineEach\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @example\n * var multiLine = turf.multiLineString([\n *   [[26, 37], [35, 45]],\n *   [[36, 53], [38, 50], [41, 55]]\n * ]);\n *\n * turf.lineEach(multiLine, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction lineEach(geojson, callback) {\n    // validation\n    if (!geojson) throw new Error('geojson is required');\n\n    flattenEach(geojson, function (feature$$1, featureIndex, multiFeatureIndex) {\n        if (feature$$1.geometry === null) return;\n        var type = feature$$1.geometry.type;\n        var coords = feature$$1.geometry.coordinates;\n        switch (type) {\n        case 'LineString':\n            if (callback(feature$$1, featureIndex, multiFeatureIndex, 0, 0) === false) return false;\n            break;\n        case 'Polygon':\n            for (var geometryIndex = 0; geometryIndex < coords.length; geometryIndex++) {\n                if (callback(lineString(coords[geometryIndex], feature$$1.properties), featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n            }\n            break;\n        }\n    });\n}\n\n/**\n * Callback for lineReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback lineReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name lineReduce\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var multiPoly = turf.multiPolygon([\n *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),\n *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])\n * ]);\n *\n * turf.lineReduce(multiPoly, function (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentLine\n * });\n */\nfunction lineReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    lineEach(geojson, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentLine;\n        else previousValue = callback(previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Finds a particular 2-vertex LineString Segment from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n * Point & MultiPoint will always return null.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.segmentIndex=0] Segment Index\n * @param {Object} [options.properties={}] Translate Properties to output LineString\n * @param {BBox} [options.bbox={}] Translate BBox to output LineString\n * @param {number|string} [options.id={}] Translate Id to output LineString\n * @returns {Feature<LineString>} 2-vertex GeoJSON Feature LineString\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findSegment(multiLine);\n * // => Feature<LineString<[[10, 10], [50, 30]]>>\n *\n * // First Segment of 2nd Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: 1});\n * // => Feature<LineString<[[-10, -10], [-50, -30]]>>\n *\n * // Last Segment of Last Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: -1, segmentIndex: -1});\n * // => Feature<LineString<[[-50, -30], [-30, -40]]>>\n */\nfunction findSegment(geojson, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var featureIndex = options.featureIndex || 0;\n    var multiFeatureIndex = options.multiFeatureIndex || 0;\n    var geometryIndex = options.geometryIndex || 0;\n    var segmentIndex = options.segmentIndex || 0;\n\n    // Find FeatureIndex\n    var properties = options.properties;\n    var geometry;\n\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;\n        properties = properties || geojson.features[featureIndex].properties;\n        geometry = geojson.features[featureIndex].geometry;\n        break;\n    case 'Feature':\n        properties = properties || geojson.properties;\n        geometry = geojson.geometry;\n        break;\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n    case 'Polygon':\n    case 'MultiLineString':\n    case 'MultiPolygon':\n        geometry = geojson;\n        break;\n    default:\n        throw new Error('geojson is invalid');\n    }\n\n    // Find SegmentIndex\n    if (geometry === null) return null;\n    var coords = geometry.coordinates;\n    switch (geometry.type) {\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n        if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;\n        return lineString([coords[segmentIndex], coords[segmentIndex + 1]], properties, options);\n    case 'Polygon':\n        if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n        if (segmentIndex < 0) segmentIndex = coords[geometryIndex].length + segmentIndex - 1;\n        return lineString([coords[geometryIndex][segmentIndex], coords[geometryIndex][segmentIndex + 1]], properties, options);\n    case 'MultiLineString':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;\n        return lineString([coords[multiFeatureIndex][segmentIndex], coords[multiFeatureIndex][segmentIndex + 1]], properties, options);\n    case 'MultiPolygon':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n        if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;\n        return lineString([coords[multiFeatureIndex][geometryIndex][segmentIndex], coords[multiFeatureIndex][geometryIndex][segmentIndex + 1]], properties, options);\n    }\n    throw new Error('geojson is invalid');\n}\n\n/**\n * Finds a particular Point from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.coordIndex=0] Coord Index\n * @param {Object} [options.properties={}] Translate Properties to output Point\n * @param {BBox} [options.bbox={}] Translate BBox to output Point\n * @param {number|string} [options.id={}] Translate Id to output Point\n * @returns {Feature<Point>} 2-vertex GeoJSON Feature Point\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findPoint(multiLine);\n * // => Feature<Point<[10, 10]>>\n *\n * // First Segment of the 2nd Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: 1});\n * // => Feature<Point<[-10, -10]>>\n *\n * // Last Segment of last Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: -1, coordIndex: -1});\n * // => Feature<Point<[-30, -40]>>\n */\nfunction findPoint(geojson, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var featureIndex = options.featureIndex || 0;\n    var multiFeatureIndex = options.multiFeatureIndex || 0;\n    var geometryIndex = options.geometryIndex || 0;\n    var coordIndex = options.coordIndex || 0;\n\n    // Find FeatureIndex\n    var properties = options.properties;\n    var geometry;\n\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;\n        properties = properties || geojson.features[featureIndex].properties;\n        geometry = geojson.features[featureIndex].geometry;\n        break;\n    case 'Feature':\n        properties = properties || geojson.properties;\n        geometry = geojson.geometry;\n        break;\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n    case 'Polygon':\n    case 'MultiLineString':\n    case 'MultiPolygon':\n        geometry = geojson;\n        break;\n    default:\n        throw new Error('geojson is invalid');\n    }\n\n    // Find Coord Index\n    if (geometry === null) return null;\n    var coords = geometry.coordinates;\n    switch (geometry.type) {\n    case 'Point':\n        return point(coords, properties, options);\n    case 'MultiPoint':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        return point(coords[multiFeatureIndex], properties, options);\n    case 'LineString':\n        if (coordIndex < 0) coordIndex = coords.length + coordIndex;\n        return point(coords[coordIndex], properties, options);\n    case 'Polygon':\n        if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n        if (coordIndex < 0) coordIndex = coords[geometryIndex].length + coordIndex;\n        return point(coords[geometryIndex][coordIndex], properties, options);\n    case 'MultiLineString':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (coordIndex < 0) coordIndex = coords[multiFeatureIndex].length + coordIndex;\n        return point(coords[multiFeatureIndex][coordIndex], properties, options);\n    case 'MultiPolygon':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n        if (coordIndex < 0) coordIndex = coords[multiFeatureIndex][geometryIndex].length - coordIndex;\n        return point(coords[multiFeatureIndex][geometryIndex][coordIndex], properties, options);\n    }\n    throw new Error('geojson is invalid');\n}\n\nexport { coordEach, coordReduce, propEach, propReduce, featureEach, featureReduce, coordAll, geomEach, geomReduce, flattenEach, flattenReduce, segmentEach, segmentReduce, lineEach, lineReduce, findSegment, findPoint };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}