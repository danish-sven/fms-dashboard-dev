{"ast":null,"code":"import { Vector3, Matrix3 } from '@math.gl/core';\nimport computeEigenDecomposition from './compute-eigen-decomposition';\nimport OrientedBoundingBox from '../bounding-volumes/oriented-bounding-box';\nimport AxisAlignedBoundingBox from '../bounding-volumes/axis-aligned-bounding-box';\nconst scratchVector2 = new Vector3();\nconst scratchVector3 = new Vector3();\nconst scratchVector4 = new Vector3();\nconst scratchVector5 = new Vector3();\nconst scratchVector6 = new Vector3();\nconst scratchCovarianceResult = new Matrix3();\nconst scratchEigenResult = {\n  diagonal: new Matrix3(),\n  unitary: new Matrix3()\n};\nexport function makeOrientedBoundingBoxFromPoints(positions) {\n  let result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new OrientedBoundingBox();\n  if (!positions || positions.length === 0) {\n    result.halfAxes = new Matrix3([0, 0, 0, 0, 0, 0, 0, 0, 0]);\n    result.center = new Vector3();\n    return result;\n  }\n  const length = positions.length;\n  const meanPoint = new Vector3(0, 0, 0);\n  for (const position of positions) {\n    meanPoint.add(position);\n  }\n  const invLength = 1.0 / length;\n  meanPoint.multiplyByScalar(invLength);\n  let exx = 0.0;\n  let exy = 0.0;\n  let exz = 0.0;\n  let eyy = 0.0;\n  let eyz = 0.0;\n  let ezz = 0.0;\n  for (const position of positions) {\n    const p = scratchVector2.copy(position).subtract(meanPoint);\n    exx += p.x * p.x;\n    exy += p.x * p.y;\n    exz += p.x * p.z;\n    eyy += p.y * p.y;\n    eyz += p.y * p.z;\n    ezz += p.z * p.z;\n  }\n  exx *= invLength;\n  exy *= invLength;\n  exz *= invLength;\n  eyy *= invLength;\n  eyz *= invLength;\n  ezz *= invLength;\n  const covarianceMatrix = scratchCovarianceResult;\n  covarianceMatrix[0] = exx;\n  covarianceMatrix[1] = exy;\n  covarianceMatrix[2] = exz;\n  covarianceMatrix[3] = exy;\n  covarianceMatrix[4] = eyy;\n  covarianceMatrix[5] = eyz;\n  covarianceMatrix[6] = exz;\n  covarianceMatrix[7] = eyz;\n  covarianceMatrix[8] = ezz;\n  const {\n    unitary\n  } = computeEigenDecomposition(covarianceMatrix, scratchEigenResult);\n  const rotation = result.halfAxes.copy(unitary);\n  let v1 = rotation.getColumn(0, scratchVector4);\n  let v2 = rotation.getColumn(1, scratchVector5);\n  let v3 = rotation.getColumn(2, scratchVector6);\n  let u1 = -Number.MAX_VALUE;\n  let u2 = -Number.MAX_VALUE;\n  let u3 = -Number.MAX_VALUE;\n  let l1 = Number.MAX_VALUE;\n  let l2 = Number.MAX_VALUE;\n  let l3 = Number.MAX_VALUE;\n  for (const position of positions) {\n    scratchVector2.copy(position);\n    u1 = Math.max(scratchVector2.dot(v1), u1);\n    u2 = Math.max(scratchVector2.dot(v2), u2);\n    u3 = Math.max(scratchVector2.dot(v3), u3);\n    l1 = Math.min(scratchVector2.dot(v1), l1);\n    l2 = Math.min(scratchVector2.dot(v2), l2);\n    l3 = Math.min(scratchVector2.dot(v3), l3);\n  }\n  v1 = v1.multiplyByScalar(0.5 * (l1 + u1));\n  v2 = v2.multiplyByScalar(0.5 * (l2 + u2));\n  v3 = v3.multiplyByScalar(0.5 * (l3 + u3));\n  result.center.copy(v1).add(v2).add(v3);\n  const scale = scratchVector3.set(u1 - l1, u2 - l2, u3 - l3).multiplyByScalar(0.5);\n  const scaleMatrix = new Matrix3([scale[0], 0, 0, 0, scale[1], 0, 0, 0, scale[2]]);\n  result.halfAxes.multiplyRight(scaleMatrix);\n  return result;\n}\nexport function makeAxisAlignedBoundingBoxFromPoints(positions) {\n  let result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new AxisAlignedBoundingBox();\n  if (!positions || positions.length === 0) {\n    result.minimum.set(0, 0, 0);\n    result.maximum.set(0, 0, 0);\n    result.center.set(0, 0, 0);\n    result.halfDiagonal.set(0, 0, 0);\n    return result;\n  }\n  let minimumX = positions[0][0];\n  let minimumY = positions[0][1];\n  let minimumZ = positions[0][2];\n  let maximumX = positions[0][0];\n  let maximumY = positions[0][1];\n  let maximumZ = positions[0][2];\n  for (const p of positions) {\n    const x = p[0];\n    const y = p[1];\n    const z = p[2];\n    minimumX = Math.min(x, minimumX);\n    maximumX = Math.max(x, maximumX);\n    minimumY = Math.min(y, minimumY);\n    maximumY = Math.max(y, maximumY);\n    minimumZ = Math.min(z, minimumZ);\n    maximumZ = Math.max(z, maximumZ);\n  }\n  result.minimum.set(minimumX, minimumY, minimumZ);\n  result.maximum.set(maximumX, maximumY, maximumZ);\n  result.center.copy(result.minimum).add(result.maximum).scale(0.5);\n  result.halfDiagonal.copy(result.maximum).subtract(result.center);\n  return result;\n}","map":{"version":3,"names":["Vector3","Matrix3","computeEigenDecomposition","OrientedBoundingBox","AxisAlignedBoundingBox","scratchVector2","scratchVector3","scratchVector4","scratchVector5","scratchVector6","scratchCovarianceResult","scratchEigenResult","diagonal","unitary","makeOrientedBoundingBoxFromPoints","positions","result","arguments","length","undefined","halfAxes","center","meanPoint","position","add","invLength","multiplyByScalar","exx","exy","exz","eyy","eyz","ezz","p","copy","subtract","x","y","z","covarianceMatrix","rotation","v1","getColumn","v2","v3","u1","Number","MAX_VALUE","u2","u3","l1","l2","l3","Math","max","dot","min","scale","set","scaleMatrix","multiplyRight","makeAxisAlignedBoundingBoxFromPoints","minimum","maximum","halfDiagonal","minimumX","minimumY","minimumZ","maximumX","maximumY","maximumZ"],"sources":["../../../../src/lib/algorithms/bounding-box-from-points.ts"],"sourcesContent":["// This file is derived from the Cesium math library under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\nimport {Vector3, Matrix3} from '@math.gl/core';\nimport computeEigenDecomposition from './compute-eigen-decomposition';\nimport OrientedBoundingBox from '../bounding-volumes/oriented-bounding-box';\nimport AxisAlignedBoundingBox from '../bounding-volumes/axis-aligned-bounding-box';\n\nconst scratchVector2 = new Vector3();\n\nconst scratchVector3 = new Vector3();\n\nconst scratchVector4 = new Vector3();\n\nconst scratchVector5 = new Vector3();\n\nconst scratchVector6 = new Vector3();\n\nconst scratchCovarianceResult = new Matrix3();\n\nconst scratchEigenResult = {\n  diagonal: new Matrix3(),\n  unitary: new Matrix3()\n};\n\n/**\n * Computes an instance of an OrientedBoundingBox of the given positions.\n *\n * This is an implementation of Stefan Gottschalk's Collision Queries using Oriented Bounding Boxes solution (PHD thesis).\n * Reference: http://gamma.cs.unc.edu/users/gottschalk/main.pdf\n */\n/* eslint-disable max-statements */\nexport function makeOrientedBoundingBoxFromPoints(\n  positions: number[][],\n  result: OrientedBoundingBox = new OrientedBoundingBox()\n): OrientedBoundingBox {\n  if (!positions || positions.length === 0) {\n    result.halfAxes = new Matrix3([0, 0, 0, 0, 0, 0, 0, 0, 0]);\n    result.center = new Vector3();\n    return result;\n  }\n\n  const length = positions.length;\n  const meanPoint = new Vector3(0, 0, 0);\n  for (const position of positions) {\n    meanPoint.add(position);\n  }\n  const invLength = 1.0 / length;\n  meanPoint.multiplyByScalar(invLength);\n\n  let exx = 0.0;\n  let exy = 0.0;\n  let exz = 0.0;\n  let eyy = 0.0;\n  let eyz = 0.0;\n  let ezz = 0.0;\n\n  for (const position of positions) {\n    const p = scratchVector2.copy(position).subtract(meanPoint);\n    exx += p.x * p.x;\n    exy += p.x * p.y;\n    exz += p.x * p.z;\n    eyy += p.y * p.y;\n    eyz += p.y * p.z;\n    ezz += p.z * p.z;\n  }\n\n  exx *= invLength;\n  exy *= invLength;\n  exz *= invLength;\n  eyy *= invLength;\n  eyz *= invLength;\n  ezz *= invLength;\n\n  const covarianceMatrix = scratchCovarianceResult;\n  covarianceMatrix[0] = exx;\n  covarianceMatrix[1] = exy;\n  covarianceMatrix[2] = exz;\n  covarianceMatrix[3] = exy;\n  covarianceMatrix[4] = eyy;\n  covarianceMatrix[5] = eyz;\n  covarianceMatrix[6] = exz;\n  covarianceMatrix[7] = eyz;\n  covarianceMatrix[8] = ezz;\n\n  const {unitary} = computeEigenDecomposition(covarianceMatrix, scratchEigenResult);\n  const rotation = result.halfAxes.copy(unitary);\n\n  let v1 = rotation.getColumn(0, scratchVector4);\n  let v2 = rotation.getColumn(1, scratchVector5);\n  let v3 = rotation.getColumn(2, scratchVector6);\n\n  let u1 = -Number.MAX_VALUE;\n  let u2 = -Number.MAX_VALUE;\n  let u3 = -Number.MAX_VALUE;\n  let l1 = Number.MAX_VALUE;\n  let l2 = Number.MAX_VALUE;\n  let l3 = Number.MAX_VALUE;\n\n  for (const position of positions) {\n    scratchVector2.copy(position);\n\n    u1 = Math.max(scratchVector2.dot(v1), u1);\n    u2 = Math.max(scratchVector2.dot(v2), u2);\n    u3 = Math.max(scratchVector2.dot(v3), u3);\n\n    l1 = Math.min(scratchVector2.dot(v1), l1);\n    l2 = Math.min(scratchVector2.dot(v2), l2);\n    l3 = Math.min(scratchVector2.dot(v3), l3);\n  }\n\n  v1 = v1.multiplyByScalar(0.5 * (l1 + u1));\n  v2 = v2.multiplyByScalar(0.5 * (l2 + u2));\n  v3 = v3.multiplyByScalar(0.5 * (l3 + u3));\n\n  result.center.copy(v1).add(v2).add(v3);\n\n  const scale = scratchVector3.set(u1 - l1, u2 - l2, u3 - l3).multiplyByScalar(0.5);\n  const scaleMatrix = new Matrix3([scale[0], 0, 0, 0, scale[1], 0, 0, 0, scale[2]]);\n  result.halfAxes.multiplyRight(scaleMatrix);\n\n  return result;\n}\n\n/**\n * Computes an instance of an AxisAlignedBoundingBox. The box is determined by\n * finding the points spaced the farthest apart on the x, y, and z axes.\n */\nexport function makeAxisAlignedBoundingBoxFromPoints(\n  positions: readonly number[][],\n  result: AxisAlignedBoundingBox = new AxisAlignedBoundingBox()\n): AxisAlignedBoundingBox {\n  if (!positions || positions.length === 0) {\n    result.minimum.set(0, 0, 0);\n    result.maximum.set(0, 0, 0);\n    result.center.set(0, 0, 0);\n    result.halfDiagonal.set(0, 0, 0);\n    return result;\n  }\n\n  let minimumX = positions[0][0];\n  let minimumY = positions[0][1];\n  let minimumZ = positions[0][2];\n\n  let maximumX = positions[0][0];\n  let maximumY = positions[0][1];\n  let maximumZ = positions[0][2];\n\n  for (const p of positions) {\n    const x = p[0];\n    const y = p[1];\n    const z = p[2];\n\n    minimumX = Math.min(x, minimumX);\n    maximumX = Math.max(x, maximumX);\n    minimumY = Math.min(y, minimumY);\n    maximumY = Math.max(y, maximumY);\n    minimumZ = Math.min(z, minimumZ);\n    maximumZ = Math.max(z, maximumZ);\n  }\n\n  result.minimum.set(minimumX, minimumY, minimumZ);\n  result.maximum.set(maximumX, maximumY, maximumZ);\n  result.center.copy(result.minimum).add(result.maximum).scale(0.5);\n  result.halfDiagonal.copy(result.maximum).subtract(result.center);\n\n  return result;\n}\n"],"mappings":"AAGA,SAAQA,OAAR,EAAiBC,OAAjB,QAA+B,eAA/B;AACA,OAAOC,yBAAP,MAAsC,+BAAtC;AACA,OAAOC,mBAAP,MAAgC,2CAAhC;AACA,OAAOC,sBAAP,MAAmC,+CAAnC;AAEA,MAAMC,cAAc,GAAG,IAAIL,OAAJ,EAAvB;AAEA,MAAMM,cAAc,GAAG,IAAIN,OAAJ,EAAvB;AAEA,MAAMO,cAAc,GAAG,IAAIP,OAAJ,EAAvB;AAEA,MAAMQ,cAAc,GAAG,IAAIR,OAAJ,EAAvB;AAEA,MAAMS,cAAc,GAAG,IAAIT,OAAJ,EAAvB;AAEA,MAAMU,uBAAuB,GAAG,IAAIT,OAAJ,EAAhC;AAEA,MAAMU,kBAAkB,GAAG;EACzBC,QAAQ,EAAE,IAAIX,OAAJ,EADe;EAEzBY,OAAO,EAAE,IAAIZ,OAAJ;AAFgB,CAA3B;AAYA,OAAO,SAASa,iCAATA,CACLC,SADK,EAGgB;EAAA,IADrBC,MAA2B,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,IAAId,mBAAJ,EAFzB;EAIL,IAAI,CAACY,SAAD,IAAcA,SAAS,CAACG,MAAV,KAAqB,CAAvC,EAA0C;IACxCF,MAAM,CAACI,QAAP,GAAkB,IAAInB,OAAJ,CAAY,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,EAAa,CAAb,EAAgB,CAAhB,EAAmB,CAAnB,EAAsB,CAAtB,EAAyB,CAAzB,CAAZ,CAAlB;IACAe,MAAM,CAACK,MAAP,GAAgB,IAAIrB,OAAJ,EAAhB;IACA,OAAOgB,MAAP;EACD;EAED,MAAME,MAAM,GAAGH,SAAS,CAACG,MAAzB;EACA,MAAMI,SAAS,GAAG,IAAItB,OAAJ,CAAY,CAAZ,EAAe,CAAf,EAAkB,CAAlB,CAAlB;EACA,KAAK,MAAMuB,QAAX,IAAuBR,SAAvB,EAAkC;IAChCO,SAAS,CAACE,GAAV,CAAcD,QAAd;EACD;EACD,MAAME,SAAS,GAAG,MAAMP,MAAxB;EACAI,SAAS,CAACI,gBAAV,CAA2BD,SAA3B;EAEA,IAAIE,GAAG,GAAG,GAAV;EACA,IAAIC,GAAG,GAAG,GAAV;EACA,IAAIC,GAAG,GAAG,GAAV;EACA,IAAIC,GAAG,GAAG,GAAV;EACA,IAAIC,GAAG,GAAG,GAAV;EACA,IAAIC,GAAG,GAAG,GAAV;EAEA,KAAK,MAAMT,QAAX,IAAuBR,SAAvB,EAAkC;IAChC,MAAMkB,CAAC,GAAG5B,cAAc,CAAC6B,IAAf,CAAoBX,QAApB,EAA8BY,QAA9B,CAAuCb,SAAvC,CAAV;IACAK,GAAG,IAAIM,CAAC,CAACG,CAAF,GAAMH,CAAC,CAACG,CAAf;IACAR,GAAG,IAAIK,CAAC,CAACG,CAAF,GAAMH,CAAC,CAACI,CAAf;IACAR,GAAG,IAAII,CAAC,CAACG,CAAF,GAAMH,CAAC,CAACK,CAAf;IACAR,GAAG,IAAIG,CAAC,CAACI,CAAF,GAAMJ,CAAC,CAACI,CAAf;IACAN,GAAG,IAAIE,CAAC,CAACI,CAAF,GAAMJ,CAAC,CAACK,CAAf;IACAN,GAAG,IAAIC,CAAC,CAACK,CAAF,GAAML,CAAC,CAACK,CAAf;EACD;EAEDX,GAAG,IAAIF,SAAP;EACAG,GAAG,IAAIH,SAAP;EACAI,GAAG,IAAIJ,SAAP;EACAK,GAAG,IAAIL,SAAP;EACAM,GAAG,IAAIN,SAAP;EACAO,GAAG,IAAIP,SAAP;EAEA,MAAMc,gBAAgB,GAAG7B,uBAAzB;EACA6B,gBAAgB,CAAC,CAAD,CAAhB,GAAsBZ,GAAtB;EACAY,gBAAgB,CAAC,CAAD,CAAhB,GAAsBX,GAAtB;EACAW,gBAAgB,CAAC,CAAD,CAAhB,GAAsBV,GAAtB;EACAU,gBAAgB,CAAC,CAAD,CAAhB,GAAsBX,GAAtB;EACAW,gBAAgB,CAAC,CAAD,CAAhB,GAAsBT,GAAtB;EACAS,gBAAgB,CAAC,CAAD,CAAhB,GAAsBR,GAAtB;EACAQ,gBAAgB,CAAC,CAAD,CAAhB,GAAsBV,GAAtB;EACAU,gBAAgB,CAAC,CAAD,CAAhB,GAAsBR,GAAtB;EACAQ,gBAAgB,CAAC,CAAD,CAAhB,GAAsBP,GAAtB;EAEA,MAAM;IAACnB;EAAD,IAAYX,yBAAyB,CAACqC,gBAAD,EAAmB5B,kBAAnB,CAA3C;EACA,MAAM6B,QAAQ,GAAGxB,MAAM,CAACI,QAAP,CAAgBc,IAAhB,CAAqBrB,OAArB,CAAjB;EAEA,IAAI4B,EAAE,GAAGD,QAAQ,CAACE,SAAT,CAAmB,CAAnB,EAAsBnC,cAAtB,CAAT;EACA,IAAIoC,EAAE,GAAGH,QAAQ,CAACE,SAAT,CAAmB,CAAnB,EAAsBlC,cAAtB,CAAT;EACA,IAAIoC,EAAE,GAAGJ,QAAQ,CAACE,SAAT,CAAmB,CAAnB,EAAsBjC,cAAtB,CAAT;EAEA,IAAIoC,EAAE,GAAG,CAACC,MAAM,CAACC,SAAjB;EACA,IAAIC,EAAE,GAAG,CAACF,MAAM,CAACC,SAAjB;EACA,IAAIE,EAAE,GAAG,CAACH,MAAM,CAACC,SAAjB;EACA,IAAIG,EAAE,GAAGJ,MAAM,CAACC,SAAhB;EACA,IAAII,EAAE,GAAGL,MAAM,CAACC,SAAhB;EACA,IAAIK,EAAE,GAAGN,MAAM,CAACC,SAAhB;EAEA,KAAK,MAAMxB,QAAX,IAAuBR,SAAvB,EAAkC;IAChCV,cAAc,CAAC6B,IAAf,CAAoBX,QAApB;IAEAsB,EAAE,GAAGQ,IAAI,CAACC,GAAL,CAASjD,cAAc,CAACkD,GAAf,CAAmBd,EAAnB,CAAT,EAAiCI,EAAjC,CAAL;IACAG,EAAE,GAAGK,IAAI,CAACC,GAAL,CAASjD,cAAc,CAACkD,GAAf,CAAmBZ,EAAnB,CAAT,EAAiCK,EAAjC,CAAL;IACAC,EAAE,GAAGI,IAAI,CAACC,GAAL,CAASjD,cAAc,CAACkD,GAAf,CAAmBX,EAAnB,CAAT,EAAiCK,EAAjC,CAAL;IAEAC,EAAE,GAAGG,IAAI,CAACG,GAAL,CAASnD,cAAc,CAACkD,GAAf,CAAmBd,EAAnB,CAAT,EAAiCS,EAAjC,CAAL;IACAC,EAAE,GAAGE,IAAI,CAACG,GAAL,CAASnD,cAAc,CAACkD,GAAf,CAAmBZ,EAAnB,CAAT,EAAiCQ,EAAjC,CAAL;IACAC,EAAE,GAAGC,IAAI,CAACG,GAAL,CAASnD,cAAc,CAACkD,GAAf,CAAmBX,EAAnB,CAAT,EAAiCQ,EAAjC,CAAL;EACD;EAEDX,EAAE,GAAGA,EAAE,CAACf,gBAAH,CAAoB,OAAOwB,EAAE,GAAGL,EAAZ,CAApB,CAAL;EACAF,EAAE,GAAGA,EAAE,CAACjB,gBAAH,CAAoB,OAAOyB,EAAE,GAAGH,EAAZ,CAApB,CAAL;EACAJ,EAAE,GAAGA,EAAE,CAAClB,gBAAH,CAAoB,OAAO0B,EAAE,GAAGH,EAAZ,CAApB,CAAL;EAEAjC,MAAM,CAACK,MAAP,CAAca,IAAd,CAAmBO,EAAnB,EAAuBjB,GAAvB,CAA2BmB,EAA3B,EAA+BnB,GAA/B,CAAmCoB,EAAnC;EAEA,MAAMa,KAAK,GAAGnD,cAAc,CAACoD,GAAf,CAAmBb,EAAE,GAAGK,EAAxB,EAA4BF,EAAE,GAAGG,EAAjC,EAAqCF,EAAE,GAAGG,EAA1C,EAA8C1B,gBAA9C,CAA+D,GAA/D,CAAd;EACA,MAAMiC,WAAW,GAAG,IAAI1D,OAAJ,CAAY,CAACwD,KAAK,CAAC,CAAD,CAAN,EAAW,CAAX,EAAc,CAAd,EAAiB,CAAjB,EAAoBA,KAAK,CAAC,CAAD,CAAzB,EAA8B,CAA9B,EAAiC,CAAjC,EAAoC,CAApC,EAAuCA,KAAK,CAAC,CAAD,CAA5C,CAAZ,CAApB;EACAzC,MAAM,CAACI,QAAP,CAAgBwC,aAAhB,CAA8BD,WAA9B;EAEA,OAAO3C,MAAP;AACD;AAMD,OAAO,SAAS6C,oCAATA,CACL9C,SADK,EAGmB;EAAA,IADxBC,MAA8B,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,IAAIb,sBAAJ,EAF5B;EAIL,IAAI,CAACW,SAAD,IAAcA,SAAS,CAACG,MAAV,KAAqB,CAAvC,EAA0C;IACxCF,MAAM,CAAC8C,OAAP,CAAeJ,GAAf,CAAmB,CAAnB,EAAsB,CAAtB,EAAyB,CAAzB;IACA1C,MAAM,CAAC+C,OAAP,CAAeL,GAAf,CAAmB,CAAnB,EAAsB,CAAtB,EAAyB,CAAzB;IACA1C,MAAM,CAACK,MAAP,CAAcqC,GAAd,CAAkB,CAAlB,EAAqB,CAArB,EAAwB,CAAxB;IACA1C,MAAM,CAACgD,YAAP,CAAoBN,GAApB,CAAwB,CAAxB,EAA2B,CAA3B,EAA8B,CAA9B;IACA,OAAO1C,MAAP;EACD;EAED,IAAIiD,QAAQ,GAAGlD,SAAS,CAAC,CAAD,CAAT,CAAa,CAAb,CAAf;EACA,IAAImD,QAAQ,GAAGnD,SAAS,CAAC,CAAD,CAAT,CAAa,CAAb,CAAf;EACA,IAAIoD,QAAQ,GAAGpD,SAAS,CAAC,CAAD,CAAT,CAAa,CAAb,CAAf;EAEA,IAAIqD,QAAQ,GAAGrD,SAAS,CAAC,CAAD,CAAT,CAAa,CAAb,CAAf;EACA,IAAIsD,QAAQ,GAAGtD,SAAS,CAAC,CAAD,CAAT,CAAa,CAAb,CAAf;EACA,IAAIuD,QAAQ,GAAGvD,SAAS,CAAC,CAAD,CAAT,CAAa,CAAb,CAAf;EAEA,KAAK,MAAMkB,CAAX,IAAgBlB,SAAhB,EAA2B;IACzB,MAAMqB,CAAC,GAAGH,CAAC,CAAC,CAAD,CAAX;IACA,MAAMI,CAAC,GAAGJ,CAAC,CAAC,CAAD,CAAX;IACA,MAAMK,CAAC,GAAGL,CAAC,CAAC,CAAD,CAAX;IAEAgC,QAAQ,GAAGZ,IAAI,CAACG,GAAL,CAASpB,CAAT,EAAY6B,QAAZ,CAAX;IACAG,QAAQ,GAAGf,IAAI,CAACC,GAAL,CAASlB,CAAT,EAAYgC,QAAZ,CAAX;IACAF,QAAQ,GAAGb,IAAI,CAACG,GAAL,CAASnB,CAAT,EAAY6B,QAAZ,CAAX;IACAG,QAAQ,GAAGhB,IAAI,CAACC,GAAL,CAASjB,CAAT,EAAYgC,QAAZ,CAAX;IACAF,QAAQ,GAAGd,IAAI,CAACG,GAAL,CAASlB,CAAT,EAAY6B,QAAZ,CAAX;IACAG,QAAQ,GAAGjB,IAAI,CAACC,GAAL,CAAShB,CAAT,EAAYgC,QAAZ,CAAX;EACD;EAEDtD,MAAM,CAAC8C,OAAP,CAAeJ,GAAf,CAAmBO,QAAnB,EAA6BC,QAA7B,EAAuCC,QAAvC;EACAnD,MAAM,CAAC+C,OAAP,CAAeL,GAAf,CAAmBU,QAAnB,EAA6BC,QAA7B,EAAuCC,QAAvC;EACAtD,MAAM,CAACK,MAAP,CAAca,IAAd,CAAmBlB,MAAM,CAAC8C,OAA1B,EAAmCtC,GAAnC,CAAuCR,MAAM,CAAC+C,OAA9C,EAAuDN,KAAvD,CAA6D,GAA7D;EACAzC,MAAM,CAACgD,YAAP,CAAoB9B,IAApB,CAAyBlB,MAAM,CAAC+C,OAAhC,EAAyC5B,QAAzC,CAAkDnB,MAAM,CAACK,MAAzD;EAEA,OAAOL,MAAP;AACD"},"metadata":{},"sourceType":"module"}