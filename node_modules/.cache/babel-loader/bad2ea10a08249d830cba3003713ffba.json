{"ast":null,"code":"/**\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\n */\nvar earthRadius = 6371008.8;\n\n/**\n * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.\n */\nvar factors = {\n  meters: earthRadius,\n  metres: earthRadius,\n  millimeters: earthRadius * 1000,\n  millimetres: earthRadius * 1000,\n  centimeters: earthRadius * 100,\n  centimetres: earthRadius * 100,\n  kilometers: earthRadius / 1000,\n  kilometres: earthRadius / 1000,\n  miles: earthRadius / 1609.344,\n  nauticalmiles: earthRadius / 1852,\n  inches: earthRadius * 39.370,\n  yards: earthRadius / 1.0936,\n  feet: earthRadius * 3.28084,\n  radians: 1,\n  degrees: earthRadius / 111325\n};\n\n/**\n * Units of measurement factors based on 1 meter.\n */\nvar unitsFactors = {\n  meters: 1,\n  metres: 1,\n  millimeters: 1000,\n  millimetres: 1000,\n  centimeters: 100,\n  centimetres: 100,\n  kilometers: 1 / 1000,\n  kilometres: 1 / 1000,\n  miles: 1 / 1609.344,\n  nauticalmiles: 1 / 1852,\n  inches: 39.370,\n  yards: 1 / 1.0936,\n  feet: 3.28084,\n  radians: 1 / earthRadius,\n  degrees: 1 / 111325\n};\n\n/**\n * Area of measurement factors based on 1 square meter.\n */\nvar areaFactors = {\n  meters: 1,\n  metres: 1,\n  millimeters: 1000000,\n  millimetres: 1000000,\n  centimeters: 10000,\n  centimetres: 10000,\n  kilometers: 0.000001,\n  kilometres: 0.000001,\n  acres: 0.000247105,\n  miles: 3.86e-7,\n  yards: 1.195990046,\n  feet: 10.763910417,\n  inches: 1550.003100006\n};\n\n/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @name feature\n * @param {Geometry} geometry input geometry\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature} a GeoJSON Feature\n * @example\n * var geometry = {\n *   \"type\": \"Point\",\n *   \"coordinates\": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\nfunction feature(geometry, properties, options) {\n  // Optional Parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error('options is invalid');\n  var bbox = options.bbox;\n  var id = options.id;\n\n  // Validation\n  if (geometry === undefined) throw new Error('geometry is required');\n  if (properties && properties.constructor !== Object) throw new Error('properties must be an Object');\n  if (bbox) validateBBox(bbox);\n  if (id) validateId(id);\n\n  // Main\n  var feat = {\n    type: 'Feature'\n  };\n  if (id) feat.id = id;\n  if (bbox) feat.bbox = bbox;\n  feat.properties = properties || {};\n  feat.geometry = geometry;\n  return feat;\n}\n\n/**\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\n * For GeometryCollection type use `helpers.geometryCollection`\n *\n * @name geometry\n * @param {string} type Geometry Type\n * @param {Array<number>} coordinates Coordinates\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Geometry\n * @returns {Geometry} a GeoJSON Geometry\n * @example\n * var type = 'Point';\n * var coordinates = [110, 50];\n *\n * var geometry = turf.geometry(type, coordinates);\n *\n * //=geometry\n */\nfunction geometry(type, coordinates, options) {\n  // Optional Parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error('options is invalid');\n  var bbox = options.bbox;\n\n  // Validation\n  if (!type) throw new Error('type is required');\n  if (!coordinates) throw new Error('coordinates is required');\n  if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n  if (bbox) validateBBox(bbox);\n\n  // Main\n  var geom;\n  switch (type) {\n    case 'Point':\n      geom = point(coordinates).geometry;\n      break;\n    case 'LineString':\n      geom = lineString(coordinates).geometry;\n      break;\n    case 'Polygon':\n      geom = polygon(coordinates).geometry;\n      break;\n    case 'MultiPoint':\n      geom = multiPoint(coordinates).geometry;\n      break;\n    case 'MultiLineString':\n      geom = multiLineString(coordinates).geometry;\n      break;\n    case 'MultiPolygon':\n      geom = multiPolygon(coordinates).geometry;\n      break;\n    default:\n      throw new Error(type + ' is invalid');\n  }\n  if (bbox) geom.bbox = bbox;\n  return geom;\n}\n\n/**\n * Creates a {@link Point} {@link Feature} from a Position.\n *\n * @name point\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Point>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\nfunction point(coordinates, properties, options) {\n  if (!coordinates) throw new Error('coordinates is required');\n  if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n  if (coordinates.length < 2) throw new Error('coordinates must be at least 2 numbers long');\n  if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) throw new Error('coordinates must contain numbers');\n  return feature({\n    type: 'Point',\n    coordinates: coordinates\n  }, properties, options);\n}\n\n/**\n * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.\n *\n * @name points\n * @param {Array<Array<number>>} coordinates an array of Points\n * @param {Object} [properties={}] Translate these properties to each Feature\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Point>} Point Feature\n * @example\n * var points = turf.points([\n *   [-75, 39],\n *   [-80, 45],\n *   [-78, 50]\n * ]);\n *\n * //=points\n */\nfunction points(coordinates, properties, options) {\n  if (!coordinates) throw new Error('coordinates is required');\n  if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n  return featureCollection(coordinates.map(function (coords) {\n    return point(coords, properties);\n  }), options);\n}\n\n/**\n * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.\n *\n * @name polygon\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Polygon>} Polygon Feature\n * @example\n * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });\n *\n * //=polygon\n */\nfunction polygon(coordinates, properties, options) {\n  if (!coordinates) throw new Error('coordinates is required');\n  for (var i = 0; i < coordinates.length; i++) {\n    var ring = coordinates[i];\n    if (ring.length < 4) {\n      throw new Error('Each LinearRing of a Polygon must have 4 or more Positions.');\n    }\n    for (var j = 0; j < ring[ring.length - 1].length; j++) {\n      // Check if first point of Polygon contains two numbers\n      if (i === 0 && j === 0 && !isNumber(ring[0][0]) || !isNumber(ring[0][1])) throw new Error('coordinates must contain numbers');\n      if (ring[ring.length - 1][j] !== ring[0][j]) {\n        throw new Error('First and last Position are not equivalent.');\n      }\n    }\n  }\n  return feature({\n    type: 'Polygon',\n    coordinates: coordinates\n  }, properties, options);\n}\n\n/**\n * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.\n *\n * @name polygons\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection\n * @example\n * var polygons = turf.polygons([\n *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],\n *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],\n * ]);\n *\n * //=polygons\n */\nfunction polygons(coordinates, properties, options) {\n  if (!coordinates) throw new Error('coordinates is required');\n  if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n  return featureCollection(coordinates.map(function (coords) {\n    return polygon(coords, properties);\n  }), options);\n}\n\n/**\n * Creates a {@link LineString} {@link Feature} from an Array of Positions.\n *\n * @name lineString\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<LineString>} LineString Feature\n * @example\n * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});\n * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});\n *\n * //=linestring1\n * //=linestring2\n */\nfunction lineString(coordinates, properties, options) {\n  if (!coordinates) throw new Error('coordinates is required');\n  if (coordinates.length < 2) throw new Error('coordinates must be an array of two or more positions');\n  // Check if first point of LineString contains two numbers\n  if (!isNumber(coordinates[0][1]) || !isNumber(coordinates[0][1])) throw new Error('coordinates must contain numbers');\n  return feature({\n    type: 'LineString',\n    coordinates: coordinates\n  }, properties, options);\n}\n\n/**\n * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.\n *\n * @name lineStrings\n * @param {Array<Array<number>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<LineString>} LineString FeatureCollection\n * @example\n * var linestrings = turf.lineStrings([\n *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],\n *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]\n * ]);\n *\n * //=linestrings\n */\nfunction lineStrings(coordinates, properties, options) {\n  if (!coordinates) throw new Error('coordinates is required');\n  if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n  return featureCollection(coordinates.map(function (coords) {\n    return lineString(coords, properties);\n  }), options);\n}\n\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @name featureCollection\n * @param {Feature[]} features input features\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {FeatureCollection} FeatureCollection of Features\n * @example\n * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});\n * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});\n * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});\n *\n * var collection = turf.featureCollection([\n *   locationA,\n *   locationB,\n *   locationC\n * ]);\n *\n * //=collection\n */\nfunction featureCollection(features, options) {\n  // Optional Parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error('options is invalid');\n  var bbox = options.bbox;\n  var id = options.id;\n\n  // Validation\n  if (!features) throw new Error('No features passed');\n  if (!Array.isArray(features)) throw new Error('features must be an Array');\n  if (bbox) validateBBox(bbox);\n  if (id) validateId(id);\n\n  // Main\n  var fc = {\n    type: 'FeatureCollection'\n  };\n  if (id) fc.id = id;\n  if (bbox) fc.bbox = bbox;\n  fc.features = features;\n  return fc;\n}\n\n/**\n * Creates a {@link Feature<MultiLineString>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiLineString\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiLineString>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n */\nfunction multiLineString(coordinates, properties, options) {\n  if (!coordinates) throw new Error('coordinates is required');\n  return feature({\n    type: 'MultiLineString',\n    coordinates: coordinates\n  }, properties, options);\n}\n\n/**\n * Creates a {@link Feature<MultiPoint>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPoint\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPoint>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n */\nfunction multiPoint(coordinates, properties, options) {\n  if (!coordinates) throw new Error('coordinates is required');\n  return feature({\n    type: 'MultiPoint',\n    coordinates: coordinates\n  }, properties, options);\n}\n\n/**\n * Creates a {@link Feature<MultiPolygon>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPolygon\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPolygon>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\nfunction multiPolygon(coordinates, properties, options) {\n  if (!coordinates) throw new Error('coordinates is required');\n  return feature({\n    type: 'MultiPolygon',\n    coordinates: coordinates\n  }, properties, options);\n}\n\n/**\n * Creates a {@link Feature<GeometryCollection>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name geometryCollection\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = {\n *     \"type\": \"Point\",\n *       \"coordinates\": [100, 0]\n *     };\n * var line = {\n *     \"type\": \"LineString\",\n *     \"coordinates\": [ [101, 0], [102, 1] ]\n *   };\n * var collection = turf.geometryCollection([pt, line]);\n *\n * //=collection\n */\nfunction geometryCollection(geometries, properties, options) {\n  if (!geometries) throw new Error('geometries is required');\n  if (!Array.isArray(geometries)) throw new Error('geometries must be an Array');\n  return feature({\n    type: 'GeometryCollection',\n    geometries: geometries\n  }, properties, options);\n}\n\n/**\n * Round number to precision\n *\n * @param {number} num Number\n * @param {number} [precision=0] Precision\n * @returns {number} rounded number\n * @example\n * turf.round(120.4321)\n * //=120\n *\n * turf.round(120.4321, 2)\n * //=120.43\n */\nfunction round(num, precision) {\n  if (num === undefined || num === null || isNaN(num)) throw new Error('num is required');\n  if (precision && !(precision >= 0)) throw new Error('precision must be a positive number');\n  var multiplier = Math.pow(10, precision || 0);\n  return Math.round(num * multiplier) / multiplier;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name radiansToLength\n * @param {number} radians in radians across the sphere\n * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} distance\n */\nfunction radiansToLength(radians, units) {\n  if (radians === undefined || radians === null) throw new Error('radians is required');\n  if (units && typeof units !== 'string') throw new Error('units must be a string');\n  var factor = factors[units || 'kilometers'];\n  if (!factor) throw new Error(units + ' units is invalid');\n  return radians * factor;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name lengthToRadians\n * @param {number} distance in real units\n * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} radians\n */\nfunction lengthToRadians(distance, units) {\n  if (distance === undefined || distance === null) throw new Error('distance is required');\n  if (units && typeof units !== 'string') throw new Error('units must be a string');\n  var factor = factors[units || 'kilometers'];\n  if (!factor) throw new Error(units + ' units is invalid');\n  return distance / factor;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n *\n * @name lengthToDegrees\n * @param {number} distance in real units\n * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} degrees\n */\nfunction lengthToDegrees(distance, units) {\n  return radiansToDegrees(lengthToRadians(distance, units));\n}\n\n/**\n * Converts any bearing angle from the north line direction (positive clockwise)\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\n *\n * @name bearingToAzimuth\n * @param {number} bearing angle, between -180 and +180 degrees\n * @returns {number} angle between 0 and 360 degrees\n */\nfunction bearingToAzimuth(bearing) {\n  if (bearing === null || bearing === undefined) throw new Error('bearing is required');\n  var angle = bearing % 360;\n  if (angle < 0) angle += 360;\n  return angle;\n}\n\n/**\n * Converts an angle in radians to degrees\n *\n * @name radiansToDegrees\n * @param {number} radians angle in radians\n * @returns {number} degrees between 0 and 360 degrees\n */\nfunction radiansToDegrees(radians) {\n  if (radians === null || radians === undefined) throw new Error('radians is required');\n  var degrees = radians % (2 * Math.PI);\n  return degrees * 180 / Math.PI;\n}\n\n/**\n * Converts an angle in degrees to radians\n *\n * @name degreesToRadians\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\nfunction degreesToRadians(degrees) {\n  if (degrees === null || degrees === undefined) throw new Error('degrees is required');\n  var radians = degrees % 360;\n  return radians * Math.PI / 180;\n}\n\n/**\n * Converts a length to the requested unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @param {number} length to be converted\n * @param {string} originalUnit of the length\n * @param {string} [finalUnit='kilometers'] returned unit\n * @returns {number} the converted length\n */\nfunction convertLength(length, originalUnit, finalUnit) {\n  if (length === null || length === undefined) throw new Error('length is required');\n  if (!(length >= 0)) throw new Error('length must be a positive number');\n  return radiansToLength(lengthToRadians(length, originalUnit), finalUnit || 'kilometers');\n}\n\n/**\n * Converts a area to the requested unit.\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches\n * @param {number} area to be converted\n * @param {string} [originalUnit='meters'] of the distance\n * @param {string} [finalUnit='kilometers'] returned unit\n * @returns {number} the converted distance\n */\nfunction convertArea(area, originalUnit, finalUnit) {\n  if (area === null || area === undefined) throw new Error('area is required');\n  if (!(area >= 0)) throw new Error('area must be a positive number');\n  var startFactor = areaFactors[originalUnit || 'meters'];\n  if (!startFactor) throw new Error('invalid original units');\n  var finalFactor = areaFactors[finalUnit || 'kilometers'];\n  if (!finalFactor) throw new Error('invalid final units');\n  return area / startFactor * finalFactor;\n}\n\n/**\n * isNumber\n *\n * @param {*} num Number to validate\n * @returns {boolean} true/false\n * @example\n * turf.isNumber(123)\n * //=true\n * turf.isNumber('foo')\n * //=false\n */\nfunction isNumber(num) {\n  return !isNaN(num) && num !== null && !Array.isArray(num);\n}\n\n/**\n * isObject\n *\n * @param {*} input variable to validate\n * @returns {boolean} true/false\n * @example\n * turf.isObject({elevation: 10})\n * //=true\n * turf.isObject('foo')\n * //=false\n */\nfunction isObject(input) {\n  return !!input && input.constructor === Object;\n}\n\n/**\n * Validate BBox\n *\n * @private\n * @param {Array<number>} bbox BBox to validate\n * @returns {void}\n * @throws Error if BBox is not valid\n * @example\n * validateBBox([-180, -40, 110, 50])\n * //=OK\n * validateBBox([-180, -40])\n * //=Error\n * validateBBox('Foo')\n * //=Error\n * validateBBox(5)\n * //=Error\n * validateBBox(null)\n * //=Error\n * validateBBox(undefined)\n * //=Error\n */\nfunction validateBBox(bbox) {\n  if (!bbox) throw new Error('bbox is required');\n  if (!Array.isArray(bbox)) throw new Error('bbox must be an Array');\n  if (bbox.length !== 4 && bbox.length !== 6) throw new Error('bbox must be an Array of 4 or 6 numbers');\n  bbox.forEach(function (num) {\n    if (!isNumber(num)) throw new Error('bbox must only contain numbers');\n  });\n}\n\n/**\n * Validate Id\n *\n * @private\n * @param {string|number} id Id to validate\n * @returns {void}\n * @throws Error if Id is not valid\n * @example\n * validateId([-180, -40, 110, 50])\n * //=Error\n * validateId([-180, -40])\n * //=Error\n * validateId('Foo')\n * //=OK\n * validateId(5)\n * //=OK\n * validateId(null)\n * //=Error\n * validateId(undefined)\n * //=Error\n */\nfunction validateId(id) {\n  if (!id) throw new Error('id is required');\n  if (['string', 'number'].indexOf(typeof id) === -1) throw new Error('id must be a number or a string');\n}\n\n// Deprecated methods\nfunction radians2degrees() {\n  throw new Error('method has been renamed to `radiansToDegrees`');\n}\nfunction degrees2radians() {\n  throw new Error('method has been renamed to `degreesToRadians`');\n}\nfunction distanceToDegrees() {\n  throw new Error('method has been renamed to `lengthToDegrees`');\n}\nfunction distanceToRadians() {\n  throw new Error('method has been renamed to `lengthToRadians`');\n}\nfunction radiansToDistance() {\n  throw new Error('method has been renamed to `radiansToLength`');\n}\nfunction bearingToAngle() {\n  throw new Error('method has been renamed to `bearingToAzimuth`');\n}\nfunction convertDistance() {\n  throw new Error('method has been renamed to `convertLength`');\n}\nexport { earthRadius, factors, unitsFactors, areaFactors, feature, geometry, point, points, polygon, polygons, lineString, lineStrings, featureCollection, multiLineString, multiPoint, multiPolygon, geometryCollection, round, radiansToLength, lengthToRadians, lengthToDegrees, bearingToAzimuth, radiansToDegrees, degreesToRadians, convertLength, convertArea, isNumber, isObject, validateBBox, validateId, radians2degrees, degrees2radians, distanceToDegrees, distanceToRadians, radiansToDistance, bearingToAngle, convertDistance };","map":{"version":3,"names":["earthRadius","factors","meters","metres","millimeters","millimetres","centimeters","centimetres","kilometers","kilometres","miles","nauticalmiles","inches","yards","feet","radians","degrees","unitsFactors","areaFactors","acres","feature","geometry","properties","options","isObject","Error","bbox","id","undefined","constructor","Object","validateBBox","validateId","feat","type","coordinates","Array","isArray","geom","point","lineString","polygon","multiPoint","multiLineString","multiPolygon","length","isNumber","points","featureCollection","map","coords","i","ring","j","polygons","lineStrings","features","fc","geometryCollection","geometries","round","num","precision","isNaN","multiplier","Math","pow","radiansToLength","units","factor","lengthToRadians","distance","lengthToDegrees","radiansToDegrees","bearingToAzimuth","bearing","angle","PI","degreesToRadians","convertLength","originalUnit","finalUnit","convertArea","area","startFactor","finalFactor","input","forEach","indexOf","radians2degrees","degrees2radians","distanceToDegrees","distanceToRadians","radiansToDistance","bearingToAngle","convertDistance"],"sources":["/Users/stefanhall/Documents/Employment/Zoomo/Git/repos/fms-dashboard-dev/node_modules/@turf/helpers/main.es.js"],"sourcesContent":["/**\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\n */\nvar earthRadius = 6371008.8;\n\n/**\n * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.\n */\nvar factors = {\n    meters: earthRadius,\n    metres: earthRadius,\n    millimeters: earthRadius * 1000,\n    millimetres: earthRadius * 1000,\n    centimeters: earthRadius * 100,\n    centimetres: earthRadius * 100,\n    kilometers: earthRadius / 1000,\n    kilometres: earthRadius / 1000,\n    miles: earthRadius / 1609.344,\n    nauticalmiles: earthRadius / 1852,\n    inches: earthRadius * 39.370,\n    yards: earthRadius / 1.0936,\n    feet: earthRadius * 3.28084,\n    radians: 1,\n    degrees: earthRadius / 111325,\n};\n\n/**\n * Units of measurement factors based on 1 meter.\n */\nvar unitsFactors = {\n    meters: 1,\n    metres: 1,\n    millimeters: 1000,\n    millimetres: 1000,\n    centimeters: 100,\n    centimetres: 100,\n    kilometers: 1 / 1000,\n    kilometres: 1 / 1000,\n    miles: 1 / 1609.344,\n    nauticalmiles: 1 / 1852,\n    inches: 39.370,\n    yards: 1 / 1.0936,\n    feet: 3.28084,\n    radians: 1 / earthRadius,\n    degrees: 1 / 111325,\n};\n\n/**\n * Area of measurement factors based on 1 square meter.\n */\nvar areaFactors = {\n    meters: 1,\n    metres: 1,\n    millimeters: 1000000,\n    millimetres: 1000000,\n    centimeters: 10000,\n    centimetres: 10000,\n    kilometers: 0.000001,\n    kilometres: 0.000001,\n    acres: 0.000247105,\n    miles: 3.86e-7,\n    yards: 1.195990046,\n    feet: 10.763910417,\n    inches: 1550.003100006\n};\n\n/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @name feature\n * @param {Geometry} geometry input geometry\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature} a GeoJSON Feature\n * @example\n * var geometry = {\n *   \"type\": \"Point\",\n *   \"coordinates\": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\nfunction feature(geometry, properties, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var bbox = options.bbox;\n    var id = options.id;\n\n    // Validation\n    if (geometry === undefined) throw new Error('geometry is required');\n    if (properties && properties.constructor !== Object) throw new Error('properties must be an Object');\n    if (bbox) validateBBox(bbox);\n    if (id) validateId(id);\n\n    // Main\n    var feat = {type: 'Feature'};\n    if (id) feat.id = id;\n    if (bbox) feat.bbox = bbox;\n    feat.properties = properties || {};\n    feat.geometry = geometry;\n    return feat;\n}\n\n/**\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\n * For GeometryCollection type use `helpers.geometryCollection`\n *\n * @name geometry\n * @param {string} type Geometry Type\n * @param {Array<number>} coordinates Coordinates\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Geometry\n * @returns {Geometry} a GeoJSON Geometry\n * @example\n * var type = 'Point';\n * var coordinates = [110, 50];\n *\n * var geometry = turf.geometry(type, coordinates);\n *\n * //=geometry\n */\nfunction geometry(type, coordinates, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var bbox = options.bbox;\n\n    // Validation\n    if (!type) throw new Error('type is required');\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n    if (bbox) validateBBox(bbox);\n\n    // Main\n    var geom;\n    switch (type) {\n    case 'Point': geom = point(coordinates).geometry; break;\n    case 'LineString': geom = lineString(coordinates).geometry; break;\n    case 'Polygon': geom = polygon(coordinates).geometry; break;\n    case 'MultiPoint': geom = multiPoint(coordinates).geometry; break;\n    case 'MultiLineString': geom = multiLineString(coordinates).geometry; break;\n    case 'MultiPolygon': geom = multiPolygon(coordinates).geometry; break;\n    default: throw new Error(type + ' is invalid');\n    }\n    if (bbox) geom.bbox = bbox;\n    return geom;\n}\n\n/**\n * Creates a {@link Point} {@link Feature} from a Position.\n *\n * @name point\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Point>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\nfunction point(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n    if (coordinates.length < 2) throw new Error('coordinates must be at least 2 numbers long');\n    if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) throw new Error('coordinates must contain numbers');\n\n    return feature({\n        type: 'Point',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.\n *\n * @name points\n * @param {Array<Array<number>>} coordinates an array of Points\n * @param {Object} [properties={}] Translate these properties to each Feature\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Point>} Point Feature\n * @example\n * var points = turf.points([\n *   [-75, 39],\n *   [-80, 45],\n *   [-78, 50]\n * ]);\n *\n * //=points\n */\nfunction points(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n\n    return featureCollection(coordinates.map(function (coords) {\n        return point(coords, properties);\n    }), options);\n}\n\n/**\n * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.\n *\n * @name polygon\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Polygon>} Polygon Feature\n * @example\n * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });\n *\n * //=polygon\n */\nfunction polygon(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n\n    for (var i = 0; i < coordinates.length; i++) {\n        var ring = coordinates[i];\n        if (ring.length < 4) {\n            throw new Error('Each LinearRing of a Polygon must have 4 or more Positions.');\n        }\n        for (var j = 0; j < ring[ring.length - 1].length; j++) {\n            // Check if first point of Polygon contains two numbers\n            if (i === 0 && j === 0 && !isNumber(ring[0][0]) || !isNumber(ring[0][1])) throw new Error('coordinates must contain numbers');\n            if (ring[ring.length - 1][j] !== ring[0][j]) {\n                throw new Error('First and last Position are not equivalent.');\n            }\n        }\n    }\n\n    return feature({\n        type: 'Polygon',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.\n *\n * @name polygons\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection\n * @example\n * var polygons = turf.polygons([\n *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],\n *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],\n * ]);\n *\n * //=polygons\n */\nfunction polygons(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n\n    return featureCollection(coordinates.map(function (coords) {\n        return polygon(coords, properties);\n    }), options);\n}\n\n/**\n * Creates a {@link LineString} {@link Feature} from an Array of Positions.\n *\n * @name lineString\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<LineString>} LineString Feature\n * @example\n * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});\n * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});\n *\n * //=linestring1\n * //=linestring2\n */\nfunction lineString(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (coordinates.length < 2) throw new Error('coordinates must be an array of two or more positions');\n    // Check if first point of LineString contains two numbers\n    if (!isNumber(coordinates[0][1]) || !isNumber(coordinates[0][1])) throw new Error('coordinates must contain numbers');\n\n    return feature({\n        type: 'LineString',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.\n *\n * @name lineStrings\n * @param {Array<Array<number>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<LineString>} LineString FeatureCollection\n * @example\n * var linestrings = turf.lineStrings([\n *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],\n *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]\n * ]);\n *\n * //=linestrings\n */\nfunction lineStrings(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n\n    return featureCollection(coordinates.map(function (coords) {\n        return lineString(coords, properties);\n    }), options);\n}\n\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @name featureCollection\n * @param {Feature[]} features input features\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {FeatureCollection} FeatureCollection of Features\n * @example\n * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});\n * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});\n * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});\n *\n * var collection = turf.featureCollection([\n *   locationA,\n *   locationB,\n *   locationC\n * ]);\n *\n * //=collection\n */\nfunction featureCollection(features, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var bbox = options.bbox;\n    var id = options.id;\n\n    // Validation\n    if (!features) throw new Error('No features passed');\n    if (!Array.isArray(features)) throw new Error('features must be an Array');\n    if (bbox) validateBBox(bbox);\n    if (id) validateId(id);\n\n    // Main\n    var fc = {type: 'FeatureCollection'};\n    if (id) fc.id = id;\n    if (bbox) fc.bbox = bbox;\n    fc.features = features;\n    return fc;\n}\n\n/**\n * Creates a {@link Feature<MultiLineString>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiLineString\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiLineString>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n */\nfunction multiLineString(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n\n    return feature({\n        type: 'MultiLineString',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Feature<MultiPoint>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPoint\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPoint>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n */\nfunction multiPoint(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n\n    return feature({\n        type: 'MultiPoint',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Feature<MultiPolygon>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPolygon\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPolygon>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\nfunction multiPolygon(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n\n    return feature({\n        type: 'MultiPolygon',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Feature<GeometryCollection>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name geometryCollection\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = {\n *     \"type\": \"Point\",\n *       \"coordinates\": [100, 0]\n *     };\n * var line = {\n *     \"type\": \"LineString\",\n *     \"coordinates\": [ [101, 0], [102, 1] ]\n *   };\n * var collection = turf.geometryCollection([pt, line]);\n *\n * //=collection\n */\nfunction geometryCollection(geometries, properties, options) {\n    if (!geometries) throw new Error('geometries is required');\n    if (!Array.isArray(geometries)) throw new Error('geometries must be an Array');\n\n    return feature({\n        type: 'GeometryCollection',\n        geometries: geometries\n    }, properties, options);\n}\n\n/**\n * Round number to precision\n *\n * @param {number} num Number\n * @param {number} [precision=0] Precision\n * @returns {number} rounded number\n * @example\n * turf.round(120.4321)\n * //=120\n *\n * turf.round(120.4321, 2)\n * //=120.43\n */\nfunction round(num, precision) {\n    if (num === undefined || num === null || isNaN(num)) throw new Error('num is required');\n    if (precision && !(precision >= 0)) throw new Error('precision must be a positive number');\n    var multiplier = Math.pow(10, precision || 0);\n    return Math.round(num * multiplier) / multiplier;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name radiansToLength\n * @param {number} radians in radians across the sphere\n * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} distance\n */\nfunction radiansToLength(radians, units) {\n    if (radians === undefined || radians === null) throw new Error('radians is required');\n\n    if (units && typeof units !== 'string') throw new Error('units must be a string');\n    var factor = factors[units || 'kilometers'];\n    if (!factor) throw new Error(units + ' units is invalid');\n    return radians * factor;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name lengthToRadians\n * @param {number} distance in real units\n * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} radians\n */\nfunction lengthToRadians(distance, units) {\n    if (distance === undefined || distance === null) throw new Error('distance is required');\n\n    if (units && typeof units !== 'string') throw new Error('units must be a string');\n    var factor = factors[units || 'kilometers'];\n    if (!factor) throw new Error(units + ' units is invalid');\n    return distance / factor;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n *\n * @name lengthToDegrees\n * @param {number} distance in real units\n * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} degrees\n */\nfunction lengthToDegrees(distance, units) {\n    return radiansToDegrees(lengthToRadians(distance, units));\n}\n\n/**\n * Converts any bearing angle from the north line direction (positive clockwise)\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\n *\n * @name bearingToAzimuth\n * @param {number} bearing angle, between -180 and +180 degrees\n * @returns {number} angle between 0 and 360 degrees\n */\nfunction bearingToAzimuth(bearing) {\n    if (bearing === null || bearing === undefined) throw new Error('bearing is required');\n\n    var angle = bearing % 360;\n    if (angle < 0) angle += 360;\n    return angle;\n}\n\n/**\n * Converts an angle in radians to degrees\n *\n * @name radiansToDegrees\n * @param {number} radians angle in radians\n * @returns {number} degrees between 0 and 360 degrees\n */\nfunction radiansToDegrees(radians) {\n    if (radians === null || radians === undefined) throw new Error('radians is required');\n\n    var degrees = radians % (2 * Math.PI);\n    return degrees * 180 / Math.PI;\n}\n\n/**\n * Converts an angle in degrees to radians\n *\n * @name degreesToRadians\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\nfunction degreesToRadians(degrees) {\n    if (degrees === null || degrees === undefined) throw new Error('degrees is required');\n\n    var radians = degrees % 360;\n    return radians * Math.PI / 180;\n}\n\n/**\n * Converts a length to the requested unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @param {number} length to be converted\n * @param {string} originalUnit of the length\n * @param {string} [finalUnit='kilometers'] returned unit\n * @returns {number} the converted length\n */\nfunction convertLength(length, originalUnit, finalUnit) {\n    if (length === null || length === undefined) throw new Error('length is required');\n    if (!(length >= 0)) throw new Error('length must be a positive number');\n\n    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit || 'kilometers');\n}\n\n/**\n * Converts a area to the requested unit.\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches\n * @param {number} area to be converted\n * @param {string} [originalUnit='meters'] of the distance\n * @param {string} [finalUnit='kilometers'] returned unit\n * @returns {number} the converted distance\n */\nfunction convertArea(area, originalUnit, finalUnit) {\n    if (area === null || area === undefined) throw new Error('area is required');\n    if (!(area >= 0)) throw new Error('area must be a positive number');\n\n    var startFactor = areaFactors[originalUnit || 'meters'];\n    if (!startFactor) throw new Error('invalid original units');\n\n    var finalFactor = areaFactors[finalUnit || 'kilometers'];\n    if (!finalFactor) throw new Error('invalid final units');\n\n    return (area / startFactor) * finalFactor;\n}\n\n/**\n * isNumber\n *\n * @param {*} num Number to validate\n * @returns {boolean} true/false\n * @example\n * turf.isNumber(123)\n * //=true\n * turf.isNumber('foo')\n * //=false\n */\nfunction isNumber(num) {\n    return !isNaN(num) && num !== null && !Array.isArray(num);\n}\n\n/**\n * isObject\n *\n * @param {*} input variable to validate\n * @returns {boolean} true/false\n * @example\n * turf.isObject({elevation: 10})\n * //=true\n * turf.isObject('foo')\n * //=false\n */\nfunction isObject(input) {\n    return (!!input) && (input.constructor === Object);\n}\n\n/**\n * Validate BBox\n *\n * @private\n * @param {Array<number>} bbox BBox to validate\n * @returns {void}\n * @throws Error if BBox is not valid\n * @example\n * validateBBox([-180, -40, 110, 50])\n * //=OK\n * validateBBox([-180, -40])\n * //=Error\n * validateBBox('Foo')\n * //=Error\n * validateBBox(5)\n * //=Error\n * validateBBox(null)\n * //=Error\n * validateBBox(undefined)\n * //=Error\n */\nfunction validateBBox(bbox) {\n    if (!bbox) throw new Error('bbox is required');\n    if (!Array.isArray(bbox)) throw new Error('bbox must be an Array');\n    if (bbox.length !== 4 && bbox.length !== 6) throw new Error('bbox must be an Array of 4 or 6 numbers');\n    bbox.forEach(function (num) {\n        if (!isNumber(num)) throw new Error('bbox must only contain numbers');\n    });\n}\n\n/**\n * Validate Id\n *\n * @private\n * @param {string|number} id Id to validate\n * @returns {void}\n * @throws Error if Id is not valid\n * @example\n * validateId([-180, -40, 110, 50])\n * //=Error\n * validateId([-180, -40])\n * //=Error\n * validateId('Foo')\n * //=OK\n * validateId(5)\n * //=OK\n * validateId(null)\n * //=Error\n * validateId(undefined)\n * //=Error\n */\nfunction validateId(id) {\n    if (!id) throw new Error('id is required');\n    if (['string', 'number'].indexOf(typeof id) === -1) throw new Error('id must be a number or a string');\n}\n\n// Deprecated methods\nfunction radians2degrees() {\n    throw new Error('method has been renamed to `radiansToDegrees`');\n}\n\nfunction degrees2radians() {\n    throw new Error('method has been renamed to `degreesToRadians`');\n}\n\nfunction distanceToDegrees() {\n    throw new Error('method has been renamed to `lengthToDegrees`');\n}\n\nfunction distanceToRadians() {\n    throw new Error('method has been renamed to `lengthToRadians`');\n}\n\nfunction radiansToDistance() {\n    throw new Error('method has been renamed to `radiansToLength`');\n}\n\nfunction bearingToAngle() {\n    throw new Error('method has been renamed to `bearingToAzimuth`');\n}\n\nfunction convertDistance() {\n    throw new Error('method has been renamed to `convertLength`');\n}\n\nexport { earthRadius, factors, unitsFactors, areaFactors, feature, geometry, point, points, polygon, polygons, lineString, lineStrings, featureCollection, multiLineString, multiPoint, multiPolygon, geometryCollection, round, radiansToLength, lengthToRadians, lengthToDegrees, bearingToAzimuth, radiansToDegrees, degreesToRadians, convertLength, convertArea, isNumber, isObject, validateBBox, validateId, radians2degrees, degrees2radians, distanceToDegrees, distanceToRadians, radiansToDistance, bearingToAngle, convertDistance };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}