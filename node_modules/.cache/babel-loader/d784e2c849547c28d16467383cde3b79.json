{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { LayerExtension } from '@deck.gl/core';\nimport { Texture2D } from '@luma.gl/core';\nimport { patternShaders } from './shaders.glsl';\nconst defaultProps = {\n  fillPatternEnabled: true,\n  fillPatternAtlas: {\n    type: 'image',\n    value: null,\n    async: true,\n    parameters: {\n      [10241]: 9729\n    }\n  },\n  fillPatternMapping: {\n    type: 'object',\n    value: {},\n    async: true\n  },\n  fillPatternMask: true,\n  getFillPattern: {\n    type: 'accessor',\n    value: d => d.pattern\n  },\n  getFillPatternScale: {\n    type: 'accessor',\n    value: 1\n  },\n  getFillPatternOffset: {\n    type: 'accessor',\n    value: [0, 0]\n  }\n};\nexport default class FillStyleExtension extends LayerExtension {\n  constructor() {\n    let {\n      pattern = false\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super({\n      pattern\n    });\n  }\n  isEnabled(layer) {\n    return layer.getAttributeManager() !== null && !('pathTesselator' in layer.state);\n  }\n  getShaders(extension) {\n    if (!extension.isEnabled(this)) {\n      return null;\n    }\n    return {\n      modules: [extension.opts.pattern && patternShaders].filter(Boolean)\n    };\n  }\n  initializeState(context, extension) {\n    if (!extension.isEnabled(this)) {\n      return;\n    }\n    const attributeManager = this.getAttributeManager();\n    if (extension.opts.pattern) {\n      attributeManager.add({\n        fillPatternFrames: {\n          size: 4,\n          accessor: 'getFillPattern',\n          transform: extension.getPatternFrame.bind(this),\n          shaderAttributes: {\n            fillPatternFrames: {\n              divisor: 0\n            },\n            instanceFillPatternFrames: {\n              divisor: 1\n            }\n          }\n        },\n        fillPatternScales: {\n          size: 1,\n          accessor: 'getFillPatternScale',\n          defaultValue: 1,\n          shaderAttributes: {\n            fillPatternScales: {\n              divisor: 0\n            },\n            instanceFillPatternScales: {\n              divisor: 1\n            }\n          }\n        },\n        fillPatternOffsets: {\n          size: 2,\n          accessor: 'getFillPatternOffset',\n          shaderAttributes: {\n            fillPatternOffsets: {\n              divisor: 0\n            },\n            instanceFillPatternOffsets: {\n              divisor: 1\n            }\n          }\n        }\n      });\n    }\n    this.setState({\n      emptyTexture: new Texture2D(this.context.gl, {\n        data: new Uint8Array(4),\n        width: 1,\n        height: 1\n      })\n    });\n  }\n  updateState(_ref, extension) {\n    let {\n      props,\n      oldProps\n    } = _ref;\n    if (!extension.isEnabled(this)) {\n      return;\n    }\n    if (props.fillPatternMapping && props.fillPatternMapping !== oldProps.fillPatternMapping) {\n      this.getAttributeManager().invalidate('getFillPattern');\n    }\n  }\n  draw(params, extension) {\n    if (!extension.isEnabled(this)) {\n      return;\n    }\n    const {\n      fillPatternAtlas\n    } = this.props;\n    this.setModuleParameters({\n      fillPatternTexture: fillPatternAtlas || this.state.emptyTexture\n    });\n  }\n  finalizeState() {\n    const {\n      emptyTexture\n    } = this.state;\n    emptyTexture === null || emptyTexture === void 0 ? void 0 : emptyTexture.delete();\n  }\n  getPatternFrame(name) {\n    const {\n      fillPatternMapping\n    } = this.getCurrentLayer().props;\n    const def = fillPatternMapping && fillPatternMapping[name];\n    return def ? [def.x, def.y, def.width, def.height] : [0, 0, 0, 0];\n  }\n}\n_defineProperty(FillStyleExtension, \"defaultProps\", defaultProps);\n_defineProperty(FillStyleExtension, \"extensionName\", 'FillStyleExtension');","map":{"version":3,"names":["LayerExtension","Texture2D","patternShaders","defaultProps","fillPatternEnabled","fillPatternAtlas","type","value","async","parameters","fillPatternMapping","fillPatternMask","getFillPattern","d","pattern","getFillPatternScale","getFillPatternOffset","FillStyleExtension","constructor","arguments","length","undefined","isEnabled","layer","getAttributeManager","state","getShaders","extension","modules","opts","filter","Boolean","initializeState","context","attributeManager","add","fillPatternFrames","size","accessor","transform","getPatternFrame","bind","shaderAttributes","divisor","instanceFillPatternFrames","fillPatternScales","defaultValue","instanceFillPatternScales","fillPatternOffsets","instanceFillPatternOffsets","setState","emptyTexture","gl","data","Uint8Array","width","height","updateState","_ref","props","oldProps","invalidate","draw","params","setModuleParameters","fillPatternTexture","finalizeState","delete","name","getCurrentLayer","def","x","y"],"sources":["../../../src/fill-style/fill-style-extension.ts"],"sourcesContent":["import {LayerExtension} from '@deck.gl/core';\nimport {Texture2D} from '@luma.gl/core';\nimport GL from '@luma.gl/constants';\n\nimport {patternShaders} from './shaders.glsl';\n\nimport type {\n  Layer,\n  LayerContext,\n  Accessor,\n  AccessorFunction,\n  Texture,\n  UpdateParameters\n} from '@deck.gl/core';\n\nconst defaultProps = {\n  fillPatternEnabled: true,\n  fillPatternAtlas: {\n    type: 'image',\n    value: null,\n    async: true,\n    parameters: {\n      [GL.TEXTURE_MIN_FILTER]: GL.LINEAR\n    }\n  },\n  fillPatternMapping: {type: 'object', value: {}, async: true},\n  fillPatternMask: true,\n  getFillPattern: {type: 'accessor', value: d => d.pattern},\n  getFillPatternScale: {type: 'accessor', value: 1},\n  getFillPatternOffset: {type: 'accessor', value: [0, 0]}\n};\n\nexport type FillStyleExtensionProps<DataT = any> = {\n  /** Cheap toggle to enable/disable pattern fill. Requires the `pattern` option to be on.\n   * @default true\n   */\n  fillPatternEnabled?: boolean;\n  /** Sprite image url or texture that packs all your patterns into one layout. */\n  fillPatternAtlas?: string | Texture;\n  /** Pattern names mapped to pattern definitions, or a url that points to a JSON file. */\n  fillPatternMapping?:\n    | string\n    | Record<\n        string,\n        {\n          /** Left position of the pattern on the atlas */\n          x: number;\n          /** Top position of the pattern on the atlas */\n          y: number;\n          /** Width of the pattern */\n          width: number;\n          /** Height of the pattern */\n          height: number;\n        }\n      >;\n  /**\n   * Whether to treat the patterns as transparency masks.\n   * @default true\n   */\n  fillPatternMask?: boolean;\n  /** Accessor for the name of the pattern. */\n  getFillPattern?: AccessorFunction<DataT, string>;\n  /** Accessor for the scale of the pattern, relative to the original size. If the pattern is 24 x 24 pixels, scale `1` roughly yields 24 meters.\n   * @default 1\n   */\n  getFillPatternScale?: Accessor<DataT, number>;\n  /**\n   * Accessor for the offset of the pattern, relative to the original size. Offset `[0.5, 0.5]` shifts the pattern alignment by half.\n   * @default [0, 0]\n   */\n  getFillPatternOffset?: Accessor<DataT, [number, number]>;\n};\n\ntype FillStyleExtensionOptions = {\n  /** If `true`, adds the ability to tile the filled area with a pattern.\n   * @default false\n   */\n  pattern: boolean;\n};\n\n/** Adds selected features to layers that render a \"fill\", such as the `PolygonLayer` and `ScatterplotLayer`. */\nexport default class FillStyleExtension extends LayerExtension<FillStyleExtensionOptions> {\n  static defaultProps = defaultProps;\n  static extensionName = 'FillStyleExtension';\n\n  constructor({pattern = false}: Partial<FillStyleExtensionOptions> = {}) {\n    super({pattern});\n  }\n\n  isEnabled(layer: Layer<FillStyleExtensionProps>): boolean {\n    return layer.getAttributeManager() !== null && !('pathTesselator' in layer.state);\n  }\n\n  getShaders(this: Layer<FillStyleExtensionProps>, extension: this): any {\n    if (!extension.isEnabled(this)) {\n      return null;\n    }\n\n    return {\n      modules: [extension.opts.pattern && patternShaders].filter(Boolean)\n    };\n  }\n\n  initializeState(this: Layer<FillStyleExtensionProps>, context: LayerContext, extension: this) {\n    if (!extension.isEnabled(this)) {\n      return;\n    }\n\n    const attributeManager = this.getAttributeManager();\n\n    if (extension.opts.pattern) {\n      attributeManager!.add({\n        fillPatternFrames: {\n          size: 4,\n          accessor: 'getFillPattern',\n          transform: extension.getPatternFrame.bind(this),\n          shaderAttributes: {\n            fillPatternFrames: {\n              divisor: 0\n            },\n            instanceFillPatternFrames: {\n              divisor: 1\n            }\n          }\n        },\n        fillPatternScales: {\n          size: 1,\n          accessor: 'getFillPatternScale',\n          defaultValue: 1,\n          shaderAttributes: {\n            fillPatternScales: {\n              divisor: 0\n            },\n            instanceFillPatternScales: {\n              divisor: 1\n            }\n          }\n        },\n        fillPatternOffsets: {\n          size: 2,\n          accessor: 'getFillPatternOffset',\n          shaderAttributes: {\n            fillPatternOffsets: {\n              divisor: 0\n            },\n            instanceFillPatternOffsets: {\n              divisor: 1\n            }\n          }\n        }\n      });\n    }\n    this.setState({\n      emptyTexture: new Texture2D(this.context.gl, {\n        data: new Uint8Array(4),\n        width: 1,\n        height: 1\n      })\n    });\n  }\n\n  updateState(\n    this: Layer<FillStyleExtensionProps>,\n    {props, oldProps}: UpdateParameters<Layer<FillStyleExtensionProps>>,\n    extension: this\n  ) {\n    if (!extension.isEnabled(this)) {\n      return;\n    }\n\n    if (props.fillPatternMapping && props.fillPatternMapping !== oldProps.fillPatternMapping) {\n      this.getAttributeManager()!.invalidate('getFillPattern');\n    }\n  }\n\n  draw(this: Layer<FillStyleExtensionProps>, params: any, extension: this) {\n    if (!extension.isEnabled(this)) {\n      return;\n    }\n\n    const {fillPatternAtlas} = this.props;\n    this.setModuleParameters({\n      fillPatternTexture: fillPatternAtlas || this.state.emptyTexture\n    });\n  }\n\n  finalizeState(this: Layer<FillStyleExtensionProps>) {\n    const {emptyTexture} = this.state;\n    emptyTexture?.delete();\n  }\n\n  getPatternFrame(this: Layer<FillStyleExtensionProps>, name: string) {\n    const {fillPatternMapping} = this.getCurrentLayer()!.props;\n    const def = fillPatternMapping && fillPatternMapping[name];\n    return def ? [def.x, def.y, def.width, def.height] : [0, 0, 0, 0];\n  }\n}\n"],"mappings":";AAAA,SAAQA,cAAR,QAA6B,eAA7B;AACA,SAAQC,SAAR,QAAwB,eAAxB;AAGA,SAAQC,cAAR,QAA6B,gBAA7B;AAWA,MAAMC,YAAY,GAAG;EACnBC,kBAAkB,EAAE,IADD;EAEnBC,gBAAgB,EAAE;IAChBC,IAAI,EAAE,OADU;IAEhBC,KAAK,EAAE,IAFS;IAGhBC,KAAK,EAAE,IAHS;IAIhBC,UAAU,EAAE;MACV;IADU;EAJI,CAFC;EAUnBC,kBAAkB,EAAE;IAACJ,IAAI,EAAE,QAAP;IAAiBC,KAAK,EAAE,EAAxB;IAA4BC,KAAK,EAAE;EAAnC,CAVD;EAWnBG,eAAe,EAAE,IAXE;EAYnBC,cAAc,EAAE;IAACN,IAAI,EAAE,UAAP;IAAmBC,KAAK,EAAEM,CAAC,IAAIA,CAAC,CAACC;EAAjC,CAZG;EAanBC,mBAAmB,EAAE;IAACT,IAAI,EAAE,UAAP;IAAmBC,KAAK,EAAE;EAA1B,CAbF;EAcnBS,oBAAoB,EAAE;IAACV,IAAI,EAAE,UAAP;IAAmBC,KAAK,EAAE,CAAC,CAAD,EAAI,CAAJ;EAA1B;AAdH,CAArB;AAkEA,eAAe,MAAMU,kBAAN,SAAiCjB,cAAjC,CAA2E;EAIxFkB,WAAWA,CAAA,EAA6D;IAAA,IAA5D;MAACJ,OAAO,GAAG;IAAX,IAAAK,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAwD,EAAzD;IACT,MAAM;MAACL;IAAD,CAAN;EACD;EAEDQ,SAASA,CAACC,KAAD,EAAiD;IACxD,OAAOA,KAAK,CAACC,mBAAN,OAAgC,IAAhC,IAAwC,EAAE,oBAAoBD,KAAK,CAACE,KAA5B,CAA/C;EACD;EAEDC,UAAUA,CAAuCC,SAAvC,EAA6D;IACrE,IAAI,CAACA,SAAS,CAACL,SAAV,CAAoB,IAApB,CAAL,EAAgC;MAC9B,OAAO,IAAP;IACD;IAED,OAAO;MACLM,OAAO,EAAE,CAACD,SAAS,CAACE,IAAV,CAAef,OAAf,IAA0BZ,cAA3B,EAA2C4B,MAA3C,CAAkDC,OAAlD;IADJ,CAAP;EAGD;EAEDC,eAAeA,CAAuCC,OAAvC,EAA8DN,SAA9D,EAA+E;IAC5F,IAAI,CAACA,SAAS,CAACL,SAAV,CAAoB,IAApB,CAAL,EAAgC;MAC9B;IACD;IAED,MAAMY,gBAAgB,GAAG,KAAKV,mBAAL,EAAzB;IAEA,IAAIG,SAAS,CAACE,IAAV,CAAef,OAAnB,EAA4B;MAC1BoB,gBAAgB,CAAEC,GAAlB,CAAsB;QACpBC,iBAAiB,EAAE;UACjBC,IAAI,EAAE,CADW;UAEjBC,QAAQ,EAAE,gBAFO;UAGjBC,SAAS,EAAEZ,SAAS,CAACa,eAAV,CAA0BC,IAA1B,CAA+B,IAA/B,CAHM;UAIjBC,gBAAgB,EAAE;YAChBN,iBAAiB,EAAE;cACjBO,OAAO,EAAE;YADQ,CADH;YAIhBC,yBAAyB,EAAE;cACzBD,OAAO,EAAE;YADgB;UAJX;QAJD,CADC;QAcpBE,iBAAiB,EAAE;UACjBR,IAAI,EAAE,CADW;UAEjBC,QAAQ,EAAE,qBAFO;UAGjBQ,YAAY,EAAE,CAHG;UAIjBJ,gBAAgB,EAAE;YAChBG,iBAAiB,EAAE;cACjBF,OAAO,EAAE;YADQ,CADH;YAIhBI,yBAAyB,EAAE;cACzBJ,OAAO,EAAE;YADgB;UAJX;QAJD,CAdC;QA2BpBK,kBAAkB,EAAE;UAClBX,IAAI,EAAE,CADY;UAElBC,QAAQ,EAAE,sBAFQ;UAGlBI,gBAAgB,EAAE;YAChBM,kBAAkB,EAAE;cAClBL,OAAO,EAAE;YADS,CADJ;YAIhBM,0BAA0B,EAAE;cAC1BN,OAAO,EAAE;YADiB;UAJZ;QAHA;MA3BA,CAAtB;IAwCD;IACD,KAAKO,QAAL,CAAc;MACZC,YAAY,EAAE,IAAIlD,SAAJ,CAAc,KAAKgC,OAAL,CAAamB,EAA3B,EAA+B;QAC3CC,IAAI,EAAE,IAAIC,UAAJ,CAAe,CAAf,CADqC;QAE3CC,KAAK,EAAE,CAFoC;QAG3CC,MAAM,EAAE;MAHmC,CAA/B;IADF,CAAd;EAOD;EAEDC,WAAWA,CAAAC,IAAA,EAGT/B,SAHS,EAIT;IAAA,IAFA;MAACgC,KAAD;MAAQC;IAAR,CAFS,GAAAF,IAAA;IAKT,IAAI,CAAC/B,SAAS,CAACL,SAAV,CAAoB,IAApB,CAAL,EAAgC;MAC9B;IACD;IAED,IAAIqC,KAAK,CAACjD,kBAAN,IAA4BiD,KAAK,CAACjD,kBAAN,KAA6BkD,QAAQ,CAAClD,kBAAtE,EAA0F;MACxF,KAAKc,mBAAL,GAA4BqC,UAA5B,CAAuC,gBAAvC;IACD;EACF;EAEDC,IAAIA,CAAuCC,MAAvC,EAAoDpC,SAApD,EAAqE;IACvE,IAAI,CAACA,SAAS,CAACL,SAAV,CAAoB,IAApB,CAAL,EAAgC;MAC9B;IACD;IAED,MAAM;MAACjB;IAAD,IAAqB,KAAKsD,KAAhC;IACA,KAAKK,mBAAL,CAAyB;MACvBC,kBAAkB,EAAE5D,gBAAgB,IAAI,KAAKoB,KAAL,CAAW0B;IAD5B,CAAzB;EAGD;EAEDe,aAAaA,CAAA,EAAuC;IAClD,MAAM;MAACf;IAAD,IAAiB,KAAK1B,KAA5B;IACA0B,YAAY,SAAZ,IAAAA,YAAY,WAAZ,YAAAA,YAAY,CAAEgB,MAAd;EACD;EAED3B,eAAeA,CAAuC4B,IAAvC,EAAqD;IAClE,MAAM;MAAC1D;IAAD,IAAuB,KAAK2D,eAAL,GAAwBV,KAArD;IACA,MAAMW,GAAG,GAAG5D,kBAAkB,IAAIA,kBAAkB,CAAC0D,IAAD,CAApD;IACA,OAAOE,GAAG,GAAG,CAACA,GAAG,CAACC,CAAL,EAAQD,GAAG,CAACE,CAAZ,EAAeF,GAAG,CAACf,KAAnB,EAA0Be,GAAG,CAACd,MAA9B,CAAH,GAA2C,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,CAArD;EACD;AAlHuF;gBAArEvC,kB,kBACGd,Y;gBADHc,kB,mBAEI,oB"},"metadata":{},"sourceType":"module"}